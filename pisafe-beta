#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021"

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room

SCRIPTNAME="${0##*/}"
SCRIPTVER="0.6.3"
PRODUCTNAME="Pi Safe"
PRODUCTCOMMENT="Create or flash image files of your Raspberry Pi"
CURRENT_DIR=$(pwd)

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }

INTERFACE="GUI"  # GUI or CLI
INDEV=
OUTDEV=
SD_DEV=
INFILE=
OUTFILE=
BACKTITLE="$PRODUCTNAME ver $SCRIPTVER"


help() {
    echo "$PRODUCTNAME ver $SCRIPTVER."
    echo "$PRODUCTNAME will help you create image files of your Raspberry Pi"
    echo
    echo "This will  read an SD card to an image file"
    echo "or         write an image file to an SD card"
    echo
    echo "Supports .img .zip .xz and .gz files"
    echo "Naming an image-file with a '.img' extension is faster, but larger.  It is shrunk with PiShrink but not compressed with zip."
    echo "Defaults to .zip if no extension is specified"

    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Usage: "
    echo "$SCRIPTNAME                 to startup the graphical interface  This is recomended "
    echo "$SCRIPTNAME list            (to list sd devices and image files)"
    echo "$SCRIPTNAME write [file] [device]"
    echo "$SCRIPTNAME read [device] [file]"
    echo "$SCRIPTNAME install         (to install this script into /usr/local/bin/sd)"
    echo
    echo "Examples:"
    echo $SCRIPTNAME read sda newimage.zip
    echo $SCRIPTNAME read sdb newimage.xz
    echo $SCRIPTNAME write newimage.zip sda
    echo
}


calc_wt_size() {
  # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
  # output from tput. However in this case, tput detects neither stdout or 
  # stderr is a tty and so only gives default 80, 24 values

  WT_HEIGHT=18
  WT_HEIGHT_TALL=$(($(tput lines)-7))
  WT_WIDTH=$(tput cols)

  if [ -z "$WT_WIDTH" ] || [ "$WT_WIDTH" -lt 60 ]; then
    WT_WIDTH=80
  fi
  if [ "$WT_WIDTH" -gt 178 ]; then
    WT_WIDTH=80
  fi
  
  WT_WIDTH=80
  WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
  
  WT_MB_HEIGHT=20
  WT_MB_WIDTH=60
  
  # use for copy - paste
  # $WT_HEIGHT  $WT_WIDTH
  # $WT_MB_HEIGHT  $WT_MB_WIDTH
}


echo_if_cli(){
    if [ $INTERFACE = "CLI" ] ; then
        echo $*
    fi
}


echo_red_if_cli(){
    if [ $INTERFACE = "CLI" ] ; then
        echo_red $*
    fi
}


# this is probably unused, but good reference
trim(){
    STR=$1
    echo $STR | sed 's/\s\s*/ /g' 
}


sd_size() {
    #get parameters
    INDEV=$1
    lsblk /dev/$INDEV -d -n -o size  2> /dev/null
    if [ $? != 0 ]; then
        echo 0
    fi
}


sd_size_bytes() {
    #get parameters
    INDEV=$1
    lsblk /dev/$INDEV -d -n -b -o size  2> /dev/null
    if [ $? != 0 ]; then
        echo 0
    fi
}


folder_size() {
    FOLDER=$1
    if [ -d $FOLDER ] ; then
        sudo du -sh $FOLDER | cut -d'/' -f1 | sed 's/\s\s*/ /g'
    else
        echo 0
    fi
}


file_size_kbytes() {
    FILE=$1
    if [ -f $FILE ] ; then
        ls -s $FILE | cut -d' ' -f1
    else
        echo 0
    fi
}


image_size() {
    #get parameters
    INFILE=$1
    
    case $(file_ext $INFILE) in
        img)
            ls -s -h $INFILE | cut -d' ' -f1
        ;;
        
        zip)
            echo $(( $(zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2) / 1024 / 1024 ))M
        ;;
        
        xz)
            xz -l $INFILE | grep -v Strms | sed 's/\s\s*/ /g' | cut -d' ' -f6,7
        ;;    
        
        gz)
            echo $(( $(pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g') /1024 / 1024 ))M
        ;;
        
    esac
}


image_size_bytes() {
    #get parameters
    INFILE=$1
    
    case $(file_ext $INFILE) in
        img)
            echo $((  $(ls -s $INFILE | cut -d' ' -f1) * 1024 )) 
        ;;
        
        zip)
            zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2
        ;;
        
        xz)
            #xz -l -v $INFILE | grep Uncompressed | cut -d' ' -f8 | cut -d"(" -f2 | sed -e 's/,//g'
            #xz -l -v $INFILE | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d' ' -f4 | sed -e 's/,//g'
            xz -l -v $INFILE | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1
        ;;  
          
        gz)
            #pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2
            pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g'

        ;;
        
        *)
        echo 0
        ;;
    esac
}    


freespace() {
    echo $(df . -h --output=avail | grep -v Avail)
}    


freespace_bytes() {
    echo $(df . -B1 --output=avail | grep -v Avail)
}    


file_base() {
    fullfilename=$1
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo $fname
}


file_ext() {
    fullfilename=$1
    
    filename=$(basename "$fullfilename")
    ext="${filename##*.}"
    if [ $ext == $(file_base $filename) ]; then
      ext=""
    fi
    echo $ext
}


list_sd_devices_retired() {
    # replace first sp with ~"          : sed 's/ /~"/' 
    # add " to end                      : sed 's/$/"/'
    # trim sp                       : sed  's/  */ /g'
    # replace sp with -
    # replace ~ with sp
    # replace "- with "    
    # all together                          : sed 's/ /~"/'  | sed 's/$/"/' | sed  's/  */ /g' | sed 's/ /-/g' | sed 's/~/ /g' | sed 's/"-/"/'
    
    DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | grep -v $(boot_disk) )

    if [ $? != 0 ] ; then
        #echo_red ERROR... No SD-cards found...
        echo ERROR... No SD-cards found...
        return 1
    fi
    
    # remove the spaces so menu works
    #lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ /~"/'  | sed 's/$/"/' | sed  's/  */ /g' | sed 's/ /-/g' | sed 's/~/ /g' | sed 's/"-/"/'

    # add quotes for easier reading
    lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ ./ "/' | sed 's/$/"/' | sed 's/ /     /'
}


list_sd_devices() {
    
    unset IFS
   # IFS=$'\n'
    #IFS=\n
    #echo .$IFS.
    
    DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | grep -v $(boot_disk))
    #DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | grep -v $(boot_disk) | sed 's/ ./ | /'     )
    #DEVICES=($(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ ./ | /'))
    unset IFS
    
    if [ $? != 0 ] ; then
        #echo_red ERROR... No SD-cards found...
        echo ERROR... No SD-cards found...
        return 1
    fi

  
      echo "${DEVICES[@]}"
    return 0
  
 #IFS=$'|'
    echo 0 ${DEVICES[@]}
    echo
    echo 1 "${DEVICES[@]}"
    echo
    echo 2 ""${DEVICES[@]}""
    echo
   unset IFS
   
   echo
   echo with out
#    IFS=$'|'
    echo 0 ${DEVICES[@]}
    echo
    echo 1 "${DEVICES[@]}"
    echo
    echo 2 ""${DEVICES[@]}""
    echo
   unset IFS
   
   
   
   
   
}

sd_card_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$1
}


boot_disk() {
    BOOT_PARTITION=$(lsblk -n -l | grep " /boot" | cut -d' ' -f1)
    if [[ $BOOT_PARTITION =~ "p" ]]; then
        BOOT_DRIVE=$(echo $BOOT_PARTITION | cut -d'p' -f1)
    elif [[ $BOOT_PARTITION =~ "sd" ]]; then
        BOOT_DRIVE=${BOOT_PARTITION:0:3}
    else
      echo ERROR cant find boot drive
    fi    
    echo $BOOT_DRIVE
}


list_image_files(){
    # IFS=$'\n' sorted=($(sort  <<<"${FILES[*]}")) ; unset IFS
    #IFS=$'\n' x=($(ls -1 -s -h -w1 *.img *.zip *.xz *.gz 2> /dev/null)) ; unset IFS
    #unset IFS
    #echo $x
    
    ls -1 -s -h -w1 *.img *.zip *.xz *.gz | sed 's/ /     /' 2> /dev/null
    if [ $? != 0 ] ; then
        #echo_red ERROR... No Image-files found...
        return 1
    fi
}


elapsed_time() {
    # paramaters are in seconds
    BEG=$1
    END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


# get_tools works for GUI or CLI
get_tools() {   
    if [ $INTERFACE = "CLI" ]; then
        echo -n Checking to see if required tools are installed ...
    fi
    
    if [ ! -f /usr/local/bin/pishrink.sh ] || [ ! -f /usr/bin/zip ] || [ ! -f /usr/bin/xz ] || [ ! -f /usr/bin/pigz ]  || [ ! -f /usr/bin/whiptail ] ; then
        if [ $INTERFACE = "CLI" ]; then
            echo install?
            read  -p "Install needed tools:  PiShrink, zip,  xz-tools and whiptail [y,N]?" -n 1 -r RESULT
            echo
        else  # GUI
            MSG1="\
$SCRIPTNAME requires PiShrink, zip, xz, gz and whiptail.

This will switch to a terminal screen for the installs

Install needed tools?
"

            whiptail  --backtitle "$BACKTITLE" --title "Installing needed tools" --yesno "$MSG1"  $WT_MB_HEIGHT  $WT_MB_WIDTH
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 0 ] ; then
                RESULT="y"
            elif [ $EXIT_CODE -eq 1 ] ; then
                RESULT="n"
            else
                return "$EXIT_CODE" 
            fi
        fi

        if [ $RESULT == "y" ]; then
        
            # Install PiShrink if needed
            if [ ! -f /usr/local/bin/pishrink.sh ]; then
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                echo pishrink installed.
            fi

            # get zip if needed
            if [ ! -f /usr/bin/zip ]; then
                echo_white Installing zip...
                sudo apt install zip -y
            fi
            
            # get xz if needed
            if [ ! -f /usr/bin/xz ]; then
                echo_white Installing xz-utils...
                sudo apt install xz-utils -y
            fi
            
            # get gzip if needed
            if [ ! -f /usr/bin/pigz ]; then
                echo_white Installing pigz...
                sudo apt install pigz -y
            fi
            
            # get whiptail if needed
            if [ ! -f /usr/bin/whiptail ]; then
                echo_white Installing whiptail...
                sudo apt install whiptail -y
            fi
            
        echo_white DONE... Press any key to continue ...
        read -n1   
            
        else
            if [ $INTERFACE = "CLI" ]; then
                echo_red   WARNING.  Not all the needed tools are installed.
            else
                whiptail  --backtitle "$BACKTITLE" --title WARNING --msgbox "Not all the needed tools are installed" $WT_MB_HEIGHT $WT_MB_WIDTH
            fi
        fi
    else
        echo [OK]
    fi
}    


test_select_file(){
    PS3="Select the an image file: "
    
    #select FILE in $(list_image_files);
    select FILE in $(ls -1 *.img *.zip);
    do
        echo $FILE
        break;
    
    done
}    



#
#  Arguments
#     1  Dialog title
#     2  Source path to list files and directories
#     3  File mask (by default *)
#     4  "yes" to allow go back in the file system.
#
#  Returns
#     0  if a file was selected and loads the FILE_SELECTED variable 
#        with the selected file.
#     1  if the user cancels.
#
#if dr_file_select "Please, select a file" /home/user ; then
#        echo "File Selected: \"$FILE_SELECTED\"."
#else
#        echo "Cancelled!"
#fi
# ----------------------------------------------------------------------
function gui_dr_file_select
{
    # note: does not handle spaces in file names!!!
    local TITLE=${1:-$MSG_INFO_TITLE}
    local LOCAL_PATH=${2:-$(pwd)}
    local FILE_MASK=${3:-"*"}
    local FILE_MASK='( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" )'
#local FILE_MASK='( -name "*.zip" )'
    local ALLOW_BACK=${4:-no}
    local FILES=()
    FIELD_SEPERATOR="|"

    [ "$ALLOW_BACK" != "no" ] && FILES+=(".." "..")

    # First add folders
#IFS=$'\n'       
    for DIR in $(find $LOCAL_PATH -maxdepth 1 -mindepth 1 -name "[!.]*" -type d -printf "%f " | sort 2> /dev/null)
    do
        FILES+=($DIR $FIELD_SEPERATOR"folder")
    done

#echo gui_dr_file_select folders:
#echo "${FILES[@]}"
#read n1

#echo MASK=$FILE_MASK
#read n1


    # Then add the files
    #for FILE in $(find $LOCAL_PATH -maxdepth 1 -name "$FILE_MASK" -name "[!.]*" -type f -printf "%f %s "  2> /dev/null)
    #for FILE in $(find $LOCAL_PATH -maxdepth 1  ""$FILE_MASK"" -name "[!.]*" -type f -printf "%f %s \n"  2> /dev/null)
    for FILE in $(find $LOCAL_PATH -maxdepth 1 \
                                    \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" \) \
                                    -name "[!.]*" \
                                    -type f \
                                    -printf "%f %s \n" | sort \
                                    2> /dev/null)
   
    do
        FILES+=($FILE)
    done
unset IFS

#echo gui_dr_file_select files:
#echo "${FILES[@]}"
#echo 
#echo "${FILES[@]}"
#read n1


    # sort the array
  #  IFS=$'\n' sorted=($(sort  <<<"${FILES[*]}")) ; unset IFS
    
    #printf "[%s]\n" "${sorted[@]}"
    #return

    ##FILES=("${sorted[@]}")


    # convert filesizes to mb
    re='^[0-9]+$'
    arraylength=${#FILES[@]}
    for (( i=0; i<${arraylength}; i++ )); do
        #    echo "${FILES[$i]}"
            if [[ ${FILES[$i]} =~ $re ]] ; then
               # echo "error: Not a number" >&2; exit 1
                   FILES[$i]=$(echo $FIELD_SEPERATOR$(( ${FILES[$i]} / 1024 / 1024 ))mb)
            fi
       #      echo "${FILES[$i]}"
    done
   
   
#echo step 3
#echo ""${FILES[@]}""   
#echo starting while loop  
#read -n1
   
   
#FILES=("1 |1a 2 |2a")   
   
   
#IFS=$FIELD_SEPERATOR
    while true
    do
        FILE_SELECTED=$(whiptail --clear \
                                --backtitle "$BACKTITLE" \
                                --title "$LOCAL_PATH" \
                                --menu "Choose a file" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT ""${FILES[@]}"" 3>&1 1>&2 2>&3)
#
#echo loop: FILE_SELECTED_RETURNED=$FILE_SELECTED
#read n1

        #exit if bad whiptail statement
        #${string:position:length}
        FSX=${FILE_SELECTED:0:3}
        echo $FSX
        if [ ! -z $FSX ] && [ $FSX = "Box" ]; then
            echo ERROR in whiptail in gui_dr_file_select near line 550
            exit 1
        fi
        
        if [ -z "$FILE_SELECTED" ]; then
            return 1
        else
            if [ "$FILE_SELECTED" = ".." ] && [ "$ALLOW_BACK" != "no" ]; then
                return 0

            elif [ -d "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                if gui_dr_file_select "$TITLE" "$LOCAL_PATH/$FILE_SELECTED" "$FILE_MASK" "yes" ; then
                    if [ "$FILE_SELECTED" != ".." ]; then
                        return 0
                    fi
                else
                    return 1
                fi

            elif [ -f "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                FILE_SELECTED="$LOCAL_PATH/$FILE_SELECTED"
                return 0
            fi
        fi
    done
    
    unset IFS
}


check_freespace(){
    SPACE_NEEDED=$(( $(sd_size_bytes $INDEV) + (( $(sd_size_bytes $INDEV) / 2)) ))
     
    echo_if_cli -n "Checking for enough free space on the drive ...  "
       
    if (( $(sd_size_bytes $INDEV) > $(freespace_bytes) )); then
         if [ $INTERFACE = "CLI" ] ; then
            echo
            echo_red ERROR... not enough free space on drive to create the image file.
            echo "SD size                      = $(sd_size $INDEV)"
            echo "Free space in current folder = $(freespace)"
            return 1
        else
            whiptail  --backtitle "$BACKTITLE"  --title ERROR --ok-button "Cancel" --msgbox "Not enough free space on '$PWD' '$(freespace) available' to create the image file from '$(sd_card_name $INDEV)'." $WT_MB_HEIGHT $WT_MB_WIDTH
            return 1
        fi
    fi
    
    if (( $SPACE_NEEDED > $(freespace_bytes) )); then
        if [ $INTERFACE = "CLI" ] ; then
            echo
            echo_red Warning... There may not be enough space on drive to create the image file. $(freespace) available. $(folder_size /home/pi/.local/share/Trash) in the trash.
        else
            whiptail  --backtitle "$BACKTITLE" --title WARNING --msgbox "There may not be enough space on drive to create the image file. '$(freespace) available'. $(folder_size /home/pi/.local/share/Trash) in the trash." $WT_MB_HEIGHT $WT_MB_WIDTH
        fi
    else
        if [ $INTERFACE = "CLI" ] ; then
            echo \'$(freespace)\' [OK]
        fi
    fi
}


check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
       
    echo_if_cli -n "Checking for supported file extension ...   "
    OUTFILE_EXT=$(file_ext $OUTFILE)

    case $OUTFILE_EXT in
        img | zip | xz | gz | '')
            echo_if_cli \'$OUTFILE_EXT\' [OK]
            echo 0
            return 0
        ;;
        
        *)  
            echo_red_if_cli ERROR: Unsupported file extension \'$OUTFILE_EXT\'.
            echo 1
            return 1
        ;;
    esac
}


read_sd(){
    #get parameters
    INDEV=$1
    OUTFILE=$2
    OUTFILE_BASE=$(file_base $OUTFILE)
    OUTFILE_EXT=$(file_ext $OUTFILE)
    COMPRESSION=$3
    
    
    if [ -z $COMPRESSION ] ; then
        COMPRESSION=-1
    fi
    
    
    case $COMPRESSION in
    
        -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 )
            #echo Compression=$COMPRESSION of 9
        ;;
        
        
        *)
            COMPRESSION="1"
            #echo Compression=$COMPRESSION of 9
        ;;
        
    esac
    


  
    #GET INDEV
    if [ $INTERFACE = "CLI" ] ; then
        cli_get_sddevice  # this sets global variable OUTDEV
        EXIT_CODE=$?
        echo SD-card name= \'$(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$INDEV)\'
        echo SD-card size= $(sd_size $INDEV)
        #echo SD-card TrashSize = $(folder_size /home/pi/.local/share/Trash)
    else  # GUI
        #GOOD CODE
        INDEV=$(gui_get_sddevice)
        EXIT_CODE=$?
 #echo EXIT=$EXIT_CODE  
 #echo $INDEV.     
 #echo $(sd_size_bytes $INDEV)
 
 
        #test code
 
       # INDEV=$(gui_get_sddevice_test)
       # EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi    
    
    
    # return if no valid sd-card
    if [ $(sd_size_bytes $INDEV) = 0 ]; then
        return 1
    fi
    
    
    check_in_device_size $INDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi 
    
    
    check_freespace
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi 
    
    
    #get outfile
    if [ $INTERFACE = "CLI" ] ; then
        cli_get_outfile # this sets the global variable OUTFILE
        EXIT_CODE=$?
    else
        gui_get_outfile
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    
    if [ ! -z "$OUTFILE" ] && [ -z "$OUTFILE_EXT" ]; then
        echo_if_cli Adding .zip extension...
        OUTFILE=$OUTFILE.zip
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    fi


    check_for_supported_file_extention
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi 
    
    
  
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img

    if [ $INTERFACE = "CLI" ] ; then
        echo
        read -p "Create image-file "\'$OUTFILE\'" from "\'/dev/$INDEV\'" [y,N] ?"  -n 1 -r RESULT
    else
        whiptail  --backtitle "$BACKTITLE" --title "READ : Create Image-file" --defaultno --yesno "Create image-file '$OUTFILE' from '/dev/$INDEV'  \n\nA good 8GB card on a Pi4 takes about 9 minutes."   $WT_HEIGHT $WT_WIDTH
        EXIT_CODE=$?
    
        if [ $EXIT_CODE -eq 0 ] ; then
            RESULT="y"
        elif [ $EXIT_CODE -eq 1 ] ; then
            RESULT="n"
        else
            return "$EXIT_CODE" 
        fi
    fi
    

    if [ $RESULT == "y" ]; then
    
        if [ $INTERFACE = "GUI" ] ; then
            whiptail  --backtitle "$BACKTITLE" --yes-button OK --no-button Cancel --yesno "Switching to terminal screen to watch the work ... "   $WT_MB_HEIGHT $WT_MB_WIDTH
            if [ $? != 0 ]; then return ;fi
        fi
    
        TIME1=$(date +%s)
        echo
        echo_white Step 1 of 3 - Reading SD card \'$(sd_card_name $INDEV)\' to \'$OUTFILE_BASE.img\' ...
        date
        echo $(sd_size $INDEV ) to read
        sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE_BASE.img status=progress conv=fsync 
        sleep 5s
        echo Done reading SD card
        echo_white $(ls -s -h $OUTFILE_BASE.img)
        TIME2=$(date +%s)  
        echo_white Step 1 took $(elapsed_time $TIME1 $TIME2)
        echo
       
        echo_white Step 2 of 3 - Shrinking filesystem with PiShrink ...
        sudo pishrink.sh $OUTFILE_BASE.img
        echo Done shrinking filesystem
        echo_white $(ls -s -h $OUTFILE_BASE.img)
        TIME3=$(date +%s)
        echo_white Step 2 took $(elapsed_time $TIME2 $TIME3)

        echo
        echo_white Step 3 of 3 - Compressing $OUTFILE_BASE.img to $OUTFILE ...
        
        #echo Compression level set to $COMPRESSION out of -9
        echo $SCRIPTNAME compression level set to $(echo $COMPRESSION | sed 's/-/ /g') of 9
       
        case $(file_ext $OUTFILE) in
            img)
                echo not compressing .img file ...
            ;;
            
            zip)
                # try setting dot size with  -ds 100MB      -qdgds 100m
                #echo $(file_size_kbytes $OUTFILE_BASE.img)
                #echo $(( $(file_size_kbytes $OUTFILE_BASE.img)  / 1024 / 100 ))
                #zip -db -dd -ds 100m -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                #zip -q -dg -ds 100m -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                
                ##echo ".........1.........2.........3.........4.........5.........6.........7.........8.........9.........0"
                ##echo "Estimate $(( $(file_size_kbytes $OUTFILE_BASE.img) / 1024 / 100 )) dots total (100MB ea)."
                ##zip -dbds 100m -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                
                
                FILESIZE_M=$(( $(file_size_kbytes $OUTFILE_BASE.img) / 1024))
                DOTSIZE=$(( $FILESIZE_M / 50 ))
                echo Dot size=$DOTSIZE MB
                echo -n "                      $(file_base $OUTFILE).img"
                echo ".........20........40........60........80........100%"
                zip -dbds $DOTSIZE -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                #zip -qdgds $DOTSZ -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
            ;;
            
            xz)
                xz -z -v -T0 $COMPRESSION $OUTFILE_BASE.img
                mv $OUTFILE_BASE.img.xz $OUTFILE_BASE.xz
            ;;
            
            gz)
                pigz -v $COMPRESSION $OUTFILE_BASE.img
                mv $OUTFILE_BASE.img.gz $OUTFILE_BASE.gz
            ;;
            
            
            *)
                echo_red ERROR... unsupported file extension \'$(file_ext $OUTFILE)\'.
            ;;
        esac
        
        echo Done compressing $OUTFILE_BASE.img to $OUTFILE
        echo_white $(ls -s -h $OUTFILE)
        TIME4=$(date +%s)
        echo_white  Step 3 took $(elapsed_time $TIME3 $TIME4)
        
        echo_white DONE. Press any key to continue...
        read -n1
       
        if [ $INTERFACE = "CLI" ] ; then
            echo
            echo Done creating image \'$OUTFILE\'.
            OUTFILESIZE=$(ls -s -h $OUTFILE | cut -d' ' -f1)
            echo \'$(sd_card_name $INDEV)\' compressed to $OUTFILESIZE in $(elapsed_time $TIME1 $TIME4)
            #echo_white You can rename $OUTFILE, but it is highly recomended to leave the extension as \'.$(file_ext $OUTFILE)\'.
            echo_white  You can remove \'$(sd_card_name $INDEV)\' now.
        else     
            whiptail  --backtitle "$BACKTITLE" --title " DONE "  --msgbox "\
Done creating imagefile '$OUTFILE'

'$(sd_card_name $INDEV)' compressed to $OUTFILESIZE in $(elapsed_time $TIME1 $TIME4) 

You can remove '$(sd_card_name $INDEV)' now. \
" $WT_MB_HEIGHT $WT_WIDTH
        fi
    fi  
}  


cli_get_infile(){
    echo
    echo_white Getting Image-file ...
    while [ ! -f "$INFILE" ] ; do
        echo_red \'$INFILE\' does not exist
        echo_white Available image files:
        list_image_files
        echo "Enter image-file: (eg: 2020-04-29-buster.img)"
        read INFILE
    done
    #echo $INFILE
}


cli_get_outfile(){
    # get OUTFILE
    echo
    echo_white Getting Image-file ...
    while [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] || [ -f "$OUTFILE_BASE.img" ]; do
        if [ -f "$OUTFILE" ] ; then
            echo_red ERROR file $OUTFILE exists
        fi
        
        if [ -f "$OUTFILE_BASE.img" ] ; then
            echo_red ERROR file $OUTFILE_BASE.img exists
        fi
        
        echo "Enter name of new image file to create (eg: 2020-04-29-buster)"
        read OUTFILE
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    done
    #echo $OUTFILE
}


cli_get_indev_retired(){
    echo "text to console" 
    echo_white Getting SD-card ...  
    # read the name of an sd device until it's size is greater than 0
    while [ $(sd_size_bytes $INDEV) -le 0 ]; do
        if ! [ -z $INDEV ] ; then
            echo_red /dev/$INDEV not found.  Available SD-card devices are:
        else
            echo_red Available SD-card devices are:
        fi
        list_sd_devices
        echo "Enter SD-card device name (eg: sda)"
        read INDEV
    done
}


cli_get_sddevice(){
    echo
    echo_white Getting SD-card ...
    while [ -z "$OUTDEV" ] || [ ! -e "/dev/$OUTDEV" ] ; do
        if ! [ -z $OUTDEV ] ; then
            echo_red /dev/$OUTDEV not found.
        fi    
        echo_white Available SD-card devices are:
        echo
        #echo - $(lsblk -d -n -l -o NAME,VENDOR,MODEL,TYPE,SIZE /dev/sd? )
        list_sd_devices
        echo
        echo "Enter SD-card device name (eg: sda)"
        read OUTDEV
    done
    
        echo $OUTDEV
        echo SD-card name=\'$(sd_card_name $OUTDEV)\'
        echo SD-card size=$(sd_size $OUTDEV)
}


gui_get_infile(){
    #FILE=$(gui_dr_file_select)
    #echo $FILE_SELECTED
#echo gui_get_infile: calling gui_dr_file_select    
    if gui_dr_file_select "WRITE : Select an Image-file"  ; then
        INFILE=$FILE_SELECTED
        echo FS=$FILE_SELECTED
    else
        echo "Cancelled!"
        return 1
    fi
}


gui_get_outfile(){
    echo_if_cli "Get outfile"   
    #OUTFILE=""
    OUTFILE_BASE=$(file_base $OUTFILE)
    OUTFILE_EXT=$(file_ext $OUTFILE)
    EXT_OK=$(check_for_supported_file_extention)
    OUTFILENAME=$(date +%Y-%m-%d-newimage)
           
    while [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] || [ -f "$OUTFILE_BASE.img" ] || [ $EXT_OK = 1  ]; do  
  
        if [ -f "$OUTFILE" ] ; then
            whiptail  --backtitle "$BACKTITLE"  --title ERROR  --msgbox "File '$OUTFILE' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        if [ -f "$OUTFILE_BASE.img" ] ; then
            whiptail  --backtitle "$BACKTITLE" --title ERROR --msgbox "File '$OUTFILE_BASE.img' exists"  $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        if [ $EXT_OK = 1 ] ; then
            whiptail  --backtitle "$BACKTITLE" --title ERROR --msgbox "Unsupported extention '$(file_ext $OUTFILE)' "  $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        NEWFILE=$(whiptail  --backtitle "$BACKTITLE" --title "READ : Get Filename"  --inputbox "Enter the filename (eg 2020-12-15-Buster32) \n\nIf you don't include an extension '.zip' will be added." $WT_HEIGHT $WT_WIDTH "$OUTFILENAME" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        
        if [ $EXIT_CODE = 0 ]; then 
            OUTFILENAME=$NEWFILE
            OUTFILE=$NEWFILE
            OUTFILE_BASE=$(file_base $OUTFILE)
            if [ -z $(file_ext $OUTFILE) ] ; then 
                OUTFILE=$OUTFILE.zip
            fi
            OUTFILE_EXT=$(file_ext $OUTFILE)
            EXT_OK=$(check_for_supported_file_extention)

        else    
            return $EXIT_CODE
        fi
  
    done
    
    echo $OUTFILE
}




gui_get_sddevice_old(){
    # echo $((  $(ls -s $INFILE | cut -d' ' -f1) * 1024 )) 
    #DEVICES_X=$(list_sd_devices)

    #IFS=$'\n'
    #unset IFS

#was working 
    #DEVICES=()
    #for DEVICE in $(list_sd_devices | sed 's/ /~/' | sed 's/ /_/g' | sed 's/~/ /'  2> /dev/null)
    #do
    #    DEVICES+=($DEVICE)
    #done


#new
#DEVICES=$(list_sd_devices)
 IFS=$'/n'
    DEVICES=($(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | grep -v $(boot_disk) | sed 's/ ./ | /'))
    unset IFS
    
echo ${DEVICES[@]}
read n1

IFS=$'|'
    DEVICE_SELECTED=$(whiptail --clear \
                                --backtitle "$BACKTITLE" \
                                --title "Select SD card" \
                                --menu "SD devices found" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT ""${DEVICES[@]}"" 3>&1 1>&2 2>&3)
unset IFS
   
    echo $DEVICE_SELECTED   
}



gui_get_sddevice(){

    FIELD_SEPERATOR="|"

    #get this list of sd divices and add a field seperator |    
    IFS=$'\n'
    #options=($(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ ./ | /'))
    options=($(list_sd_devices | sed 's/ ./ '$FIELD_SEPERATOR' /'))
    unset IFS
    #IFS=$' \t\n'

    #echo ${options[@]}
    #read n1

    IFS=$FIELD_SEPERATOR
    DEVICE_SELECTED=$(whiptail --clear --title "SD cards" --menu "Choose an an SD card" 30 80 10 ""${options[@]}"" 3>&1 1>&2 2>&3)
    unset IFS   
     
    echo $DEVICE_SELECTED
}





check_for_img_file(){
    INFILE=$1
    
    echo_if_cli -n "Inspecting '$INFILE' for an image file ... "
 
    case $(file_ext $INFILE) in
        img)
            IMG=$INFILE
        ;;
        
        zip)
            IMG=$(zipinfo -1 $INFILE)  
        ;;
        
        xz)
            IMG=$(xz -l $INFILE | grep .xz | sed 's/\s\s*/ /g' | cut -d' ' -f10)
            IMG=$(echo $IMG | sed 's/.xz/.img/g')
         ;;   
         
         gz)
            IMG=$(pigz -l $INFILE | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4)
         ;;
    esac
    
    
    if [ ! -z $(file_ext $IMG) ] && [ $(file_ext $IMG) == "img" ]; then
 
        echo_if_cli $IMG [OK]
        
       # fi
    else
        if [ $INTERFACE = "CLI" ] ; then
            echo_red WARNING ... No image file found in $INFILE
        else
            whiptail  --backtitle "$BACKTITLE" --title WARNING --msgbox "No image found in $INFILE" $WT_MB_WIDTH $WT_MB_HEIGHT
        fi
    fi    
}


check_in_device_size (){
    # Check if SD-card is large... maybe the wrong device
    
    echo_if_cli -n "Checking if SD-card is larger than 16GB ...     "

    if (( $(sd_size_bytes $INDEV) > 16000000000 )); then
         if [ $INTERFACE = "CLI" ] ; then
            echo
            echo_red WARNING... $INDEV is $(sd_size $INDEV).   SD card is larger than 16GB.  Use a smaller SD card if you can. 
        else
            whiptail  --backtitle "$BACKTITLE" --title WARNING   --yes-button OK --no-button Cancel --yesno "'$(sd_card_name  $INDEV)' is larger than 16GB.  Use a smaller SD card if you can, it will copy faster."   $WT_MB_HEIGHT  $WT_MB_WIDTH 
            EXIT_CODE=$?
            if [ $EXIT_CODE != 0 ];  then
                return $EXIT_CODE
            fi
        fi
    else
        echo_if_cli \'$(sd_size $INDEV)\' [OK]
    fi
}


check_out_device_size (){
    # Check if SD-card is large... maybe the wrong device
   
    echo_if_cli -n "Checking if SD-card is larger than 16GB ...     "

    if (( $(sd_size_bytes $OUTDEV) > 16000000000 )); then
         if [ $INTERFACE = "CLI" ] ; then
            echo
            echo_red WARNING... SD-card \'$(sd_card_name  $OUTDEV)\' is larger than 16GB... Are you sure it is the right device?
            #echo "$OUTDEV size=$(sd_size $OUTDEV)"
            read -p "You must type 'OK' to continue:"  -r RESULT
            if ! [ $RESULT == "OK" ]; then
                echo Exiting...
                exit
            fi
        else
            whiptail  --backtitle "$BACKTITLE" --title WARNING --yesno "'$(sd_card_name  $OUTDEV)' is larger than 16GB.  Are you sure it is the right device?"    $WT_MB_HEIGHT  $WT_MB_WIDTH
            #whiptail --title WARNING --yesno "SD-card is larger than 16GB.  Are you sure it is the right device?"    $WT_HEIGHT  $WT_WIDTH
            EXIT_CODE=$?
            if [ $EXIT_CODE != 0 ];  then
                exit $EXIT_CODE
            fi
        fi
    else
        echo_if_cli \'$(sd_size $OUTDEV)\' [OK]
    fi
}


check_if_imagefile_will_fit_on_device(){
    # Check if imagefile will fit on device    
    echo_if_cli -n "Checking if image-file will fit on SD-card ...     "

    if (( $(image_size_bytes $INFILE) > $(sd_size_bytes $OUTDEV) )); then
         if [ $INTERFACE = "CLI" ] ; then
            echo
            echo_red ERROR... Image file is larger than SD-card.
            echo "Image size =$(image_size $INFILE)"
            echo "Device size=$(sd_size $OUTDEV)"
            return 1
        else
          whiptail  --backtitle "$BACKTITLE" --title ERROR --msgbox  "Image file size '$(image_size $INFILE)' is larger than SD-card '$(sd_size $OUTDEV)'. Canceling... " $WT_MB_HEIGHT $WT_MB_WIDTH 
          return 1
        fi
    else
        echo_if_cli [OK]
    fi
}


write_sd() {
    #get parameters
    INFILE=$1
    OUTDEV=$2
    #echo "MODE=write: Write Image to SD-card (flash image)"
    
    #get infile
    if [ $INTERFACE = "CLI" ] ; then
        cli_get_infile   # this sets the global variable INFILE
        EXIT_CODE=$?
    else
#echo write_sd: calling gui_get_infile
        gui_get_infile   # this sets the global variable INFILE
       # INFILE=$(gui_get_infile)
        EXIT_CODE=$?
#echo write_sd: exited gui_get_infile
    fi
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo Image-file = \'$INFILE\'   
     
    check_for_img_file $INFILE
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi 


    # get out device
    if [ $INTERFACE = "CLI" ] ; then
        cli_get_sddevice   # this sets global variable OUTDEV
        EXIT_CODE=$?
    else
        # GOOD CODE
        OUTDEV=$(gui_get_sddevice)
        EXIT_CODE=$?
        
        #test code
        #OUTDEV=$(gui_get_sddevice_test)
        #EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi    

    check_out_device_size $OUTDEV  
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi 
     
    check_if_imagefile_will_fit_on_device $INFILE $OUTDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi 
    
    if [ $INTERFACE = "CLI" ] ; then
        #RESULT=$?
        echo
        echo_white Write \'$INFILE\' to \'$(sd_card_name $OUTDEV)\'?
        echo_red WARNING... All existing data on \'/dev/$OUTDEV\' - will be erased!
        read  -p "You must type 'YES' to continue:" -r RESULT
        echo
    else
        if (whiptail  --backtitle "$BACKTITLE" --title WARNING --defaultno --yesno "Write image '$INFILE' \nto SD card  '$OUTDEV'   $(sd_card_name $OUTDEV)  \n\nAll existing data on '/dev/$OUTDEV' - will be erased!  \nAre you sure you want to continue?" $WT_HEIGHT $WT_WIDTH) then
            echo "User selected Yes, exit status was $?."
            RESULT="YES"
        else
            echo "User selected No, exit status was $?."
            RESULT="n"
        fi
    fi
    
    if [ -z $RESULT ] ; then
      RESULT=n
    fi
   
    if  [ $RESULT = "YES" ]; then
    
         if [ $INTERFACE = "GUI" ] ; then
            whiptail  --backtitle "$BACKTITLE" --yes-button OK --no-button Cancel --yesno "Switching to terminal screen to watch the work ... "   $WT_MB_HEIGHT $WT_MB_WIDTH
            if [ $? != 0 ]; then return ;fi
        fi
              
        echo Unmounting SD-card $OUTDEV ...
        umount /dev/$OUTDEV?
        
        date
        TIME1=$(date +%s)
    
        INFILEEXT=$(file_ext $INFILE)
        
        echo        
        echo_white Writing $(image_size $INFILE) to SD-card ...     
        
        case $INFILEEXT in
            img)
                sudo dd if=$INFILE of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;
            
            
            zip)
                unzip -p $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            xz)
                xz -v -d -c $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            gz)
                pigz -v -d $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            *)
                echo_red ERROR.  Unsupported file extension.  
            ;;

        esac        
        TIME2=$(date +%s)
        echo
        
        echo_white Done. Press any key to continue...
        read -n1
 
        if [ $INTERFACE = "CLI" ]; then
            echo_white Done writing \'$INFILE\' to \'$(sd_card_name $OUTDEV)\'
            echo_white $(image_size $INFILE) written in $(elapsed_time $TIME1 $(date +%s)).
            #echo_white Total time $(elapsed_time $TIME1 $(date +%s)).
            echo_white You can remove \'$(sd_card_name $OUTDEV)\' now.
        else
            whiptail  --backtitle "$BACKTITLE" --title DONE --msgbox "\
Done writing '$INFILE' 
to '$(sd_card_name $OUTDEV)'

in $(elapsed_time $TIME1 $TIME2)

You can remove '$(sd_card_name $OUTDEV)' now. \
" $WT_MB_HEIGHT $WT_WIDTH
        fi
        
    else
        echo Exiting... did not answer \'YES\'
    fi
}


do_about() {
  whiptail  --backtitle "$BACKTITLE" --msgbox "\
This tool provides a straightforward way of doing initial
configuration of the Raspberry Pi. Although it can be run
at any time, some of the options may have difficulties if
you have heavily customised your installation.\
" 20 70 1
}


list_info() {
        echo
        echo "CURRENT SYSTEM:"
        echo "Boot disk = /dev/$(boot_disk)"
        echo "FreeSpace = $(freespace)"
        echo "TrashSize = $(folder_size /home/pi/.local/share/Trash)"
        echo "RootTrash = $(folder_size /root/.local/share/Trash)"
        
        echo ""
        echo "SD-CARD DEVICES (excluding boot device):"
        #echo $(list_sd_devices)
        echo "$(list_sd_devices)"

        echo   
        echo "IMAGE FILES:"
        #ls -s -h -w1 *.img *.zip *.xz  2> /dev/null
        echo "$(list_image_files)"
}    


gui_menu(){
    while true
    do
        MENU_CHOICE=$(whiptail \
                --clear \
                --backtitle "$BACKTITLE" \
                --title "MAIN MENU" \
                --ok-button "Select" \
                --cancel-button "Exit" \
                --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "READ"      "     Read an SD-card to an image-file " \
                "WRITE"     "     Write/flash an image-file to an SD-card" \
                "LIST"      "     List info " \
                "INSTALL"   "     Install into the menu" \
                "HELP"      "     Help " \
                 3>&1 1>&2 2>&3)
        
        #echo $MENU_CHOICE
        case $MENU_CHOICE in
            READ)
                INTERFACE="GUI"
                read_sd
            ;;
            
            WRITE)
                write_sd
            ;;
            
            LIST)
                INFO=$(list_info)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "LIST" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
            ;;
            
            INSTALL)
                install
            ;;
            
             HELP)
                INFO=$(help)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
            ;;
            
            *)
                return
            ;;
        esac
    done
}


install() {   
     
    # check to see if script is already installed.
    if [ -f /usr/local/bin/$SCRIPTNAME ]; then
        if [ $INTERFACE = "CLI" ]; then
            echo_red WARNING... file \'$SCRIPTNAME\' ver $(/usr/local/bin/$SCRIPTNAME -v) already in /usr/local/bin. 
        else
            #whiptail  --backtitle "$BACKTITLE" --title WARNING --msgbox "'$SCRIPTNAME' ver $(/usr/local/bin/$SCRIPTNAME -v) already in /usr/local/bin" $WT_MB_HEIGHT  $WT_MB_WIDTH
            WARNING_TEXT="WARNING: '$SCRIPTNAME' ver $(/usr/local/bin/$SCRIPTNAME -v) already in /usr/local/bin " 
        fi
    else
        WARNING_TEXT=
    fi
    
    MESSAGE_TEXT="Install '$PRODUCTNAME' ver '$SCRIPTVER' into /usr/local/bin \n\nand put in the 'Accessories' menu  "
    
    
    # Prompt to install
    if [ $INTERFACE = "CLI" ]; then
        read -p "Install '$SCRIPTNAME' v$SCRIPTVER to /usr/local/bin/$SCRIPTNAME [y,N] ? " -n 1 -r RESULT
        echo
    else 
        if (whiptail  --backtitle "$BACKTITLE" --title Install --defaultno --yesno "$WARNING_TEXT \n\n$MESSAGE_TEXT " $WT_HEIGHT $WT_WIDTH) then
            RESULT="y"
        else
            RESULT="n"
            return
        fi
    fi
    
    
    if [ $RESULT == "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
  
        # create the desktop file    

        echo "\
[Desktop Entry]
Type=Application
Terminal=true
Version=1.0
Name=$PRODUCTNAME
Comment=$PRODUCTCOMMENT
#Icon=rpi-imager
Icon=media-removable
Exec=lxterminal --geometry=110x40 -e $SCRIPTNAME
Categories=Utility
StartupNotify=false" > "$PRODUCTNAME.desktop"   

        sudo mv "$PRODUCTNAME.desktop" "/usr/share/applications"

    
        if [ $INTERFACE = "GUI" ]; then
            if [ -f "/usr/share/applications/$PRODUCTNAME.desktop" ]; then
                whiptail  --backtitle "$BACKTITLE" --title DONE --msgbox "$PRODUCTNAME installed" $WT_HEIGHT $WT_MB_WIDTH
            else
                whiptail  --backtitle "$BACKTITLE" --title ERROR --msgbox "$PRODUCTNAME NOT installed" $WT_HEIGHT $WT_MB_WIDTH
            fi
        else
            if [ -f "/usr/share/applications/$PRODUCTNAME.desktop" ]; then
                echo "$PRODUCTNAME installed" 
            else
                echo_red ERROR --msgbox "$PRODUCTNAME NOT installed"
            fi
        fi
    
    else
    
        if [ $INTERFACE = "CLI" ]; then
            echo $PRODUCTNAME Not installed.
        fi
    fi
    
}



# if arg = -v, then show version and exit the script
if  [ ! -z "$1" ]  && [ $1 == "-v" ]; then
    echo $SCRIPTVER
    exit
fi



calc_wt_size
get_tools
FILE_SELECTED=""
DEVICE_SELECTED=""

#test code
#gui_get_sddevice_test
#exit


case $1 in
    
    list)
        INTERFACE="CLI"
        list_info
    ;;
    
    
    read)
        INTERFACE="CLI"
        read_sd $2 $3 $4
    ;;
    
    
    write)
        INTERFACE="CLI"
        write_sd $2 $3
    ;;
    
    
    install)
        INTERFACE="CLI"
        install
    ;;
    
    
    -v)
        echo $SCRIPTVER
    ;;
    
    menu)
        INTERFACE="GUI"
        gui_menu
    ;;
    
    
    help|-h|--help)
        INTERFACE="CLI"
        cli_help
    ;;
    
        
    *)
        gui_menu  
    ;;

esac



