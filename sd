#!/bin/bash

# by Richard Reed 2018 - 2020

SD_VER="1.5.12"
CURRENT_DIR=$(pwd)
SCRIPTNAME="${0##*/}"


# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room


WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }



help() {
    echo "Raspberry pi image-file reader-writer ver $SD_VER (2020)."
    echo "This will  read an SD card to an image file"
    echo "or         write an image file to an SD card"
    echo
    echo "Supports .img .zip .xz and .gz files"
    echo "Naming an image-file with a '.img' extension is faster, but larger.  It is shrunk with PiShrink but not compressed with zip."
    echo "Defaults to .zip if no extension is specified"

    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Usage: "
    echo "$SCRIPTNAME list            (to list sd devices and image files)"
    echo "$SCRIPTNAME write [file] [device]"
    echo "$SCRIPTNAME read [device] [file]"
    echo "$SCRIPTNAME install         (to install this script into /usr/local/bin/sd)"
    echo
    echo "Examples:"
    echo $SCRIPTNAME read sda newimage.zip
    echo $SCRIPTNAME read sdb newimage.xz
    echo $SCRIPTNAME write newimage.zip sda
    echo
}


# this is probably unused, but good reference
trim(){
    STR=$1
    echo $STR | sed 's/\s\s*/ /g' 
}



sd_size() {
    #get parameters
    INDEV=$1
    lsblk /dev/$INDEV -d -n -o size  2> /dev/null
    if ! [ $? == 0 ]; then
        echo 0
    fi
}



sd_size_bytes() {
    #get parameters
    INDEV=$1
    lsblk /dev/$INDEV -d -n -b -o size  2> /dev/null
    if ! [ $? == 0 ]; then
        echo 0
    fi
}



folder_size() {
    FOLDER=$1
    if [ -d $FOLDER ] ; then
        sudo du -sh $FOLDER | cut -d'/' -f1
    else
        echo 0
    fi
}



file_size_kbytes() {
    FILE=$1
    if [ -f $FILE ] ; then
        ls -s $FILE | cut -d' ' -f1
    else
        echo 0
    fi
}



image_size() {
    #get parameters
    INFILE=$1
    
    case $(file_ext $INFILE) in
        img)
            ls -s -h $INFILE | cut -d' ' -f1
        ;;
        
        zip)
            echo $(( $(zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2) / 1024 / 1024 ))M
        ;;
        
        xz)
            xz -l $INFILE | grep -v Strms | sed 's/\s\s*/ /g' | cut -d' ' -f6,7
        ;;    
        
        gz)
            echo $(( $(pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g') /1024 / 1024 ))M
        ;;
        
    esac
}



image_size_bytes() {
    #get parameters
    INFILE=$1
    
    case $(file_ext $INFILE) in
        img)
            echo $((  $(ls -s $INFILE | cut -d' ' -f1) * 1024 )) 
        ;;
        
        zip)
            zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2
        ;;
        
        xz)
            #xz -l -v $INFILE | grep Uncompressed | cut -d' ' -f8 | cut -d"(" -f2 | sed -e 's/,//g'
            #xz -l -v $INFILE | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d' ' -f4 | sed -e 's/,//g'
            xz -l -v $INFILE | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1
        ;;  
          
        gz)
            #pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2
            pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g'

        ;;
    esac
}    



freespace() {
    echo $(df . -h --output=avail | grep -v Avail)
}    

freespace_bytes() {
    echo $(df . -B1 --output=avail | grep -v Avail)
}    



file_base() {
    fullfilename=$1
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo $fname
}



file_ext() {
    fullfilename=$1
    
    filename=$(basename "$fullfilename")
    ext="${filename##*.}"
    if [ $ext == $(file_base $filename) ]; then
      ext=""
    fi
    echo $ext
}



list_sd_devices() {
    # list blk devices excluding the boot device...
    lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/sd? | grep -v $(boot_disk)
    if ! [ $? = 0 ] ; then
        echo_red ERROR... No SD-cards found...
    fi
}



sd_card_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$1
}



boot_disk() {
    BOOT_PARTITION=$(lsblk -n -l | grep " /boot" | cut -d' ' -f1)
    if [[ $BOOT_PARTITION =~ "p" ]]; then
        BOOT_DRIVE=$(echo $BOOT_PARTITION | cut -d'p' -f1)
    elif [[ $BOOT_PARTITION =~ "sd" ]]; then
        BOOT_DRIVE=${BOOT_PARTITION:0:3}
        #$ echo ${name:0:4}
    else
      echo_red ERROR getting boot disk  
    fi    
    echo $BOOT_DRIVE
}


list_image_files(){
    ls -1 -s -h -w1 *.img *.zip *.xz *.gz 2> /dev/null
    if ! [ $? = 0 ] ; then
        #echo_red ERROR... No Image-files found...
        echo
    fi
}


elapsed_time() {
    # paramaters are in seconds
    BEG=$1
    END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}



get_tools() {
    echo -n Checking to see if required tools are installed ...
    if [ ! -f /usr/local/bin/pishrink.sh ] || [ ! -f /usr/bin/zip ] || [ ! -f /usr/bin/xz ] ; then
    
        #echo We need several software packages.  PiShrink, zip and xz.
        echo
        read  -p "Install needed tools:  PiShrink, zip and xz-tools [y,N]?" -n 1 -r RESULT
        echo
        if [ $RESULT == "y" ]; then
        
            # Install PiShrink if needed
            if [ ! -f /usr/local/bin/pishrink.sh ]; then
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                echo pishrink installed.
            fi

            # get zip if needed
            if [ ! -f /usr/bin/zip ]; then
                echo_white Installing zip...
                sudo apt install zip -y
            fi
            
            # get xz if needed
            if [ ! -f /usr/bin/xz ]; then
                echo_white Installing xz-utils...
                sudo apt install xz-utils -y
            fi
            
            # get gzip if needed
            if [ ! -f /usr/bin/pigz ]; then
                echo_white Installing pigz...
                sudo apt install pigz -y
            fi
            
        else
            echo_red   WARNING.  Not all the needed tools are installed.
        fi
    else
        echo [OK]
    fi
}    



read_sd(){
    #get parameters
    INDEV=$1
    OUTFILE=$2
    OUTFILE_BASE=$(file_base $OUTFILE)
    OUTFILE_EXT=$(file_ext $OUTFILE)
    COMPRESSION=$3
    
    
    if [ -z $COMPRESSION ] ; then
        COMPRESSION=-1
    fi
    
    
    case $COMPRESSION in
    
        -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 )
            #echo Compression=$COMPRESSION of 9
        ;;
        
        
        *)
            COMPRESSION="1"
            #echo Compression=$COMPRESSION of 9
        ;;
        
    esac
    
    
    echo MODE=read: Create Image File

    echo
    echo_white Getting SD-card ...
    # read the name of an sd device until it's size is greater than 0
    while [ $(sd_size_bytes $INDEV) -le 0 ]; do
        if ! [ -z $INFILE ] ; then
            echo_red /dev/$INDEV not found.  Available SD-card devices are:
        else
            echo_red Available SD-card devices are:
        fi
        list_sd_devices
        echo "Enter SD-card device name (eg: sda)"
        read INDEV
    done
    
    echo SD-card name= \'$(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$INDEV)\'
    echo SD-card size= $(sd_size $INDEV)
    #echo SD-card TrashSize = $(folder_size /home/pi/.local/share/Trash)
    

    # warning if sd is larger than 16GB
    echo -n "Checking for SD card over 16GB ...          "
    if (( $(sd_size_bytes $INDEV) > 16000000000 )); then
        echo
        echo_red WARNING... $INDEV is $(sd_size $INDEV).   SD card is larger than 16GB, use a smaller SD card if you can. 
    else
        echo \'$(sd_size $INDEV)\' [OK]
    fi    
    
    
    echo -n "Checking for enough space on the drive ...  "
    SPACE_NEEDED=$(( $(sd_size_bytes $INDEV) + (( $(sd_size_bytes $INDEV) / 2)) ))
    #echo sd size = $(sd_size_bytes $INDEV)
   
    if (( $(sd_size_bytes $INDEV) > $(freespace_bytes) )); then
        echo
        echo_red ERROR... not enough free space on drive to create the image file.
        echo "SD size                      = $(sd_size $INDEV)"
        echo "Free space in current folder = $(freespace)"
        return
    else
        if (( $SPACE_NEEDED > $(freespace_bytes) )); then
            echo
            echo_red Warning... There may not be enough space on drive to create the image file. $(freespace) available. $(folder_size /home/pi/.local/share/Trash) in the trash.
        else
            echo \'$(freespace)\' [OK]
        fi
    fi
    
    
    
    # add .zip if no file extension
    if [ ! -z "$OUTFILE" ] && [ -z "$OUTFILE_EXT" ]; then
        echo Adding .zip extension...
        OUTFILE=$OUTFILE.zip
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    fi

    echo
    echo_white Getting Image-file ...
    # get OUTFILE
    while [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] || [ -f "$OUTFILE_BASE.img" ]; do
        if [ -f "$OUTFILE" ] ; then
            echo_red ERROR file $OUTFILE exists
        fi
        
        if [ -f "$OUTFILE_BASE.img" ] ; then
            echo_red ERROR file $OUTFILE_BASE.img exists
        fi
        
        echo "Enter name of new image file to create (eg: 2020-04-29-buster)"
        read OUTFILE
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    done


    # add .zip if no file extension
    
    if [ ! -z "$OUTFILE" ] && [ -z "$OUTFILE_EXT" ]; then
        echo Adding .zip extension...
        OUTFILE=$OUTFILE.zip
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    fi

    echo Image file = \'$OUTFILE\'

    #echo Compression=$COMPRESSION of 9

    echo -n "Checking for supported file extension ...   "
    case $OUTFILE_EXT in
        img | zip | xz | gz)
            echo \'$OUTFILE_EXT\' [OK]
        ;;
        
        
        *)
            echo
            echo_red ERROR: Unsupported file extension \'$OUTFILE_EXT\'.
            exit 1
        ;;
    
    esac

    
  
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img

    echo
    read -p "Create image-file "\'$OUTFILE\'" from "\'/dev/$INDEV\'" [y,N] ?"  -n 1 -r RESULT
    echo

    if [ $RESULT == "y" ]; then
        TIME1=$(date +%s)
        echo
        echo_white Step 1 - Reading SD card \'$(sd_card_name $INDEV)\' to \'$OUTFILE_BASE.img\' ...
        date
        echo $(sd_size $INDEV ) to read
        sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE_BASE.img status=progress conv=fsync 
        sleep 5s
        echo Done reading SD card
        echo_white $(ls -s -h $OUTFILE_BASE.img)
        TIME2=$(date +%s)  
        echo_white Step 1 took $(elapsed_time $TIME1 $TIME2)
        echo
       
        echo_white Step 2 - Shrinking filesystem with PiShrink ...
        sudo pishrink.sh $OUTFILE_BASE.img
        echo Done shrinking filesystem
        echo_white $(ls -s -h $OUTFILE_BASE.img)
        TIME3=$(date +%s)
        echo_white Step 2 took $(elapsed_time $TIME2 $TIME3)

       
        echo
        echo_white Step 3 - Compressing $OUTFILE_BASE.img to $OUTFILE ...
        
        #echo Compression level set to $COMPRESSION out of -9
        echo $SCRIPTNAME compression level set to $(echo $COMPRESSION | sed 's/-/ /g') of 9
       
        case $(file_ext $OUTFILE) in
            img)
                echo not compressing .img file ...
            ;;
            
            zip)
                # try setting dot size with  -ds 100MB      -qdgds 100m
                #echo $(file_size_kbytes $OUTFILE_BASE.img)
                #echo $(( $(file_size_kbytes $OUTFILE_BASE.img)  / 1024 / 100 ))
                #zip -db -dd -ds 100m -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                #zip -q -dg -ds 100m -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                
                ##echo ".........1.........2.........3.........4.........5.........6.........7.........8.........9.........0"
                ##echo "Estimate $(( $(file_size_kbytes $OUTFILE_BASE.img) / 1024 / 100 )) dots total (100MB ea)."
                ##zip -dbds 100m -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                
                
                FILESIZE_M=$(( $(file_size_kbytes $OUTFILE_BASE.img) / 1024))
                DOTSIZE=$(( $FILESIZE_M / 50 ))
                echo Dot size=$DOTSIZE MB
                echo -n "                      $(file_base $OUTFILE).img"
                echo ".........20........40........60........80........100%"
                zip -dbds $DOTSIZE -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                #zip -qdgds $DOTSZ -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
                
            ;;
            
            xz)
                xz -z -v -T0 $COMPRESSION $OUTFILE_BASE.img
                mv $OUTFILE_BASE.img.xz $OUTFILE_BASE.xz
            ;;
            
            gz)
                pigz -v $COMPRESSION $OUTFILE_BASE.img
                mv $OUTFILE_BASE.img.gz $OUTFILE_BASE.gz
            ;;
            
            
            *)
                echo_red ERROR... unsupported file extension \'$(file_ext $OUTFILE)\'.
            ;;
        esac
       
        echo Done compressing $OUTFILE_BASE.img to $OUTFILE
        echo_white $(ls -s -h $OUTFILE)
        TIME4=$(date +%s)
        echo_white  Step 3 took $(elapsed_time $TIME3 $TIME4)

        echo
        echo Done creating image \'$OUTFILE\'.
        OUTFILESIZE=$(ls -s -h $OUTFILE | cut -d' ' -f1)
        echo \'$(sd_card_name $INDEV)\' compressed to $OUTFILESIZE in $(elapsed_time $TIME1 $TIME4)
        #echo_white You can rename $OUTFILE, but it is highly recomended to leave the extension as \'.$(file_ext $OUTFILE)\'.
        echo_white  You can remove \'$(sd_card_name $INDEV)\' now.
    fi  
}  



write_sd() {
    #get parameters
    INFILE=$1
    OUTDEV=$2
    echo "MODE=write: Write Image to SD-card (flash image)"
    
    
    # get INFILE
    echo
    echo_white Getting Image-file ...
    while [ ! -f "$INFILE" ] ; do
        echo_red \'$INFILE\' does not exist
        echo_white Available image files:
        list_image_files
        echo "Enter image-file: (eg: 2020-04-29-buster.img)"
        read INFILE
    done
    
        
    echo Image-file = \'$INFILE\'
    #echo
    
    
    echo -n "Inspecting '$INFILE' for an image file ... "
    case $(file_ext $INFILE) in
        img)
            IMG=$INFILE
        ;;
        
        
        zip)
            IMG=$(zipinfo -1 $INFILE)  
        ;;
        
        
        xz)
            IMG=$(xz -l $INFILE | grep .xz | sed 's/\s\s*/ /g' | cut -d' ' -f10)
            IMG=$(echo $IMG | sed 's/.xz/.img/g')
         ;;   
         
         
         gz)
            IMG=$(pigz -l $INFILE | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4)
         ;;
    esac
    
    if [ $(file_ext $IMG) == "img" ]; then
        echo $IMG [OK]
    else
        echo_red WARNING ... No image file found in $INFILE
    fi    


    echo Image size = $(image_size $INFILE)

    
    # get OUTDEV
    echo
    echo_white Getting SD-card ...
    while [ -z "$OUTDEV" ] || [ ! -e "/dev/$OUTDEV" ] ; do
        if ! [ -z $OUTDEV ] ; then
            echo_red /dev/$OUTDEV not found.
        fi    
        echo_white Available SD-card devices are:
        echo
        #echo - $(lsblk -d -n -l -o NAME,VENDOR,MODEL,TYPE,SIZE /dev/sd? )
        list_sd_devices
        echo
        echo "Enter SD-card device name (eg: sda)"
        read OUTDEV
    done


    echo SD-card name=\'$(sd_card_name $OUTDEV)\'
    echo SD-card size=$(sd_size $OUTDEV)

    
    # Check if SD-card is large... maybe the wrong device
    echo -n "Checking if SD-card is larger than 16GB ...     "
    if (( $(sd_size_bytes $OUTDEV) > 16000000000 )); then
        echo
        echo_red WARNING... SD-card \'$(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$OUTDEV)\' is larger than 16GB... Is this the right device?
        #echo "$OUTDEV size=$(sd_size $OUTDEV)"
        read -p "You must type 'OK' to continue:"  -r RESULT
        if ! [ $RESULT == "OK" ]; then
            echo Exiting...
            exit
        fi
    else
        echo \'$(sd_size $OUTDEV)\' [OK]
    fi
    
    
    # Check if imagefile will fit on device
    echo -n "Checking if image-file will fit on SD-card ...     "
    if (( $(image_size_bytes $INFILE) > $(sd_size_bytes $OUTDEV) )); then
        echo
        echo_red ERROR... Image file is larger than SD-card.
        echo "Image size =$(image_size $INFILE)"
        echo "Device size=$(sd_size $OUTDEV)"
        #return
    else
        echo [OK]
    fi
    

    echo
    echo_white Write \'$INFILE\' to \'$(sd_card_name $OUTDEV)\'?
    echo_red WARNING... All existing data on \'/dev/$OUTDEV\' - will be erased!
    read  -p "You must type 'YES' to continue:" -r RESULT
    echo
    if [ $RESULT == "YES" ]; then
        
        echo Unmounting SD-card $OUTDEV ...
        umount /dev/$OUTDEV?
        
        date
        TIME1=$(date +%s)
    
        INFILEEXT=$(file_ext $INFILE)
        
        echo        
        echo_white Writing $(image_size $INFILE) to SD-card ...     
        
        case $INFILEEXT in
            img)
                sudo dd if=$INFILE of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;
            
            
            zip)
                unzip -p $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            xz)
                xz -v -d -c $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            gz)
                pigz -v -d $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            *)
                echo_red ERROR.  Unsupported file extension.  
            ;;

        esac        
        
        echo
        echo_white Done writing \'$INFILE\' to \'$(sd_card_name $OUTDEV)\'
        echo_white $(image_size $INFILE) written in $(elapsed_time $TIME1 $(date +%s)).
        #echo_white Total time $(elapsed_time $TIME1 $(date +%s)).
        echo_white You can remove \'$(sd_card_name $OUTDEV)\' now.
    else
        echo Exiting... did not answer \'YES\'
    fi
}



list_info() {
    echo
    echo_white  Current System:
    echo Boot disk = /dev/$(boot_disk)
    echo FreeSpace = $(freespace)
    echo TrashSize = $(folder_size /home/pi/.local/share/Trash)
    echo RootTrash = $(folder_size /root/.local/share/Trash)
    
    
    echo
    echo_white "SD-card devices (excluding boot device):"
    #echo $(list_sd_devices)
    list_sd_devices

    echo    
    echo_white Image files:
    #ls -s -h -w1 *.img *.zip *.xz  2> /dev/null
    list_image_files
}    



install() {    
    if [ -f /usr/local/bin/$SCRIPTNAME ]; then
        echo_red WARNING... file \'$SCRIPTNAME\' already in /usr/local/bin. 
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    fi
    
    read -p "Install $SCRIPTNAME v$SD_VER to /usr/local/bin/sd [y,N] ? " -n 1 -r RESULT
    echo
    
    if [ $RESULT == "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/piimage
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    else
        echo Not installed.
    fi
}



# intro
if  ! [ $1 == "-v" ]; then
    echo "Copyright (c) 2018-2020 Richard Reed"
    echo $SCRIPTNAME v$SD_VER

    get_tools
fi



case $1 in
    
    list)
        list_info
    ;;
    
    
    read)
          read_sd $2 $3 $4
    ;;
    
    
    write)
          write_sd $2 $3
    ;;
    
    
    install)
        install
    ;;
    
    
    -v)
        echo $SD_VER
    ;;
    
    
    *)
        help
    ;;

esac



