#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021"

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room

SCRIPTNAME="${0##*/}"
SCRIPTVER="0.8.2"
PRODUCTNAME="PiSafe"
PRODUCTCOMMENT="Backup-to or Restore-from an Image File"
CURRENT_DIR=$(pwd)

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }


INDEV=
OUTDEV=
#SDDEV=
INFILE=
OUTFILE=
BACKTITLE="$PRODUCTNAME ver $SCRIPTVER"


#OPTIONS to consider. Not fully implemented yet
COMPRESSION=1
LOG=false
NO_SAFETY=false
verify=false


do_help() {
    echo "$PRODUCTNAME v$SCRIPTVER  - Designed for Raspberry Pi"
    echo " - Backup your SD card to an image file"
    echo " - Restore your SD card from an image file"
    echo
    echo "Usage: "
    echo "  $SCRIPTNAME [function] [xxx] [yyy]"
    echo
    echo "Function is:"
    echo "  gui                       - startup the gui menu (this is recomended)"
    echo "  list                      - list SD-devices and image-files "
    echo "  backup [device] [file]    - backup SD-card to image-file"
    echo "  restore [file] [device]   - restore image-file to SD-card"
    echo "  install                   - install this script"
    echo "  update                    - update script from webiste"
    echo "  -v                        - display version"
    echo "  help | -h                 - help"
    echo
    echo "Notes: "
    echo " - Supports .img .zip .xz and .gz files.  Appends '.zip' if no extension is specified "
    echo " - Specifying an '.img' extension is faster, but ~2X size because it is not compressed with zip."
    echo " - Prepends '/dev/' to device if not specified"
    echo " - Defaults to 'gui' if scriptname starts with 'pisafe'"
    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Examples:"
    echo $SCRIPTNAME 
    echo $SCRIPTNAME list
    echo $SCRIPTNAME backup sda newimage
    echo $SCRIPTNAME backup /dev/sdb newimage.xz
    echo $SCRIPTNAME restore newimage.zip sda
    echo
}


do_about(){
    echo "$PRODUCTNAME was started in 2017 as 'sd' by Richard Reed (github RichardMidnight)"\
        "when he was working on a Raspberry Pi Homebrdge project and needed"\
        "to make numerous restore-points.  The image writers available at the"\
        "time were not able to create a new image file" 
    echo
    echo "It was origionally called 'sd' to simplify command-line-usage."
    echo
    echo "Then in 2021, I added the graphical front-end to make it more usable by others"\
        "and renamed it 'PiSafe' which is a reference to the ventilated cupboards that would let"\
        "you 'save a pie for later' "
    echo
    echo "Use at your own risk"
    echo
    echo "I hope this is helpful to others."
    echo
}


do_beep(){
    #speaker-test -t sine -f 1000 -l 1 & sleep .3 && kill -9 $!
    speaker-test -t sign -f 700 > /dev/null  & sleep .3 && kill -9 $! 
}


do_beep_if_sound(){
     if $SOUND ; then
        do_beep
    fi
}


get_file_base() {
    local fullfilename=$1
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo $fname
}


get_file_ext() {
    local fullfilename=$1
    
    local filename=$(basename "$fullfilename")
    local ext="${filename##*.}"
    if [ $ext = $(get_file_base $filename) ]; then
      ext=""
    fi
    echo $ext
}


get_file_size_kbytes() {
    local FILE=$1
    
    if [ -f $FILE ] ; then
        ls -s $FILE | cut -d' ' -f1
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_file_size() {
    local FILE=$1
    
    if [ -f $FILE ] ; then
        ls -s -h $FILE | cut -d' ' -f1
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_sd_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE
    fi
}


get_sd_size_bytes() {
    INDEV=$1

    lsblk $INDEV -d -n -b -o size  2> /dev/null
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE       
    fi
}


get_sd_size() {
    local INDEV=$1
    
    lsblk $INDEV -d -n -o size  2> /dev/null
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE
    fi
}


get_image_size() {
    local INFILE=$1
    
    case $(get_file_ext $INFILE) in
        img)
            ls -s -h $INFILE | cut -d' ' -f1
        ;;
        
        zip)
            echo $(( $(zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2) / 1024 / 1024 ))M
        ;;
        
        xz)
            xz -l $INFILE | grep -v Strms | sed 's/\s\s*/ /g' | cut -d' ' -f6,7
        ;;    
        
        gz)
            echo $(( $(pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g') /1024 / 1024 ))M
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
}


get_image_size_bytes() {
    local INFILE=$1
    
    case $(get_file_ext $INFILE) in
        img)
            echo $((  $(ls -s $INFILE | cut -d' ' -f1) * 1024 )) 
        ;;
        
        zip)
            zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2
        ;;
        
        xz)
            xz -l -v $INFILE | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1
        ;;  
          
        gz)
            pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g'
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
}    


get_root_disk() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    ROOT_PARTITION=$(lsblk -l | grep "/$" | cut -d' ' -f1 2> /dev/null) 
    
    if [ -z $ROOT_PARTITION ]; then
        return 1  # can't find root partition or root drive
    fi
    
    if [[ $ROOT_PARTITION =~ "p" ]]; then
        ROOT_DRIVE=$(echo $ROOT_PARTITION | cut -d'p' -f1)
    elif [[ $ROOT_PARTITION =~ "sd" ]]; then
        ROOT_DRIVE=${ROOT_PARTITION:0:3}
    else
        return 2  # can't find root disk
    fi    
    echo $ROOT_DRIVE
}


get_freespace() {
    local RET
    RET=$(df . -h --output=avail | grep -v Avail)
    
    echo $RET
}    


get_freespace_bytes() {
    local RET
    RET=$(df . -B1 --output=avail | grep -v Avail)
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo $RET
}   


get_folder_size() {
    local FOLDER=$1
    
    if [ -d $FOLDER ] ; then
        sudo du -sh $FOLDER | cut -d'/' -f1 | sed 's/\s\s*/ /g'
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


get_ver_to_int() {
	# this is not currently used... but clever
	local IFS=.
	parts=($1)
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


# ---------------------------------------------------------


check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
    OUTFILE_EXT=$(get_file_ext $OUTFILE)

    case $OUTFILE_EXT in
        img | zip | xz | gz |"" )
            return 0
        ;;
        
        *)  
            return 1
        ;;
    esac
}


check_for_img_file(){
    INFILE=$1
    local IMG
    
    echo -n "Inspecting '$INFILE' for an image file ... "
 
    case $(get_file_ext $INFILE) in
        img)
            IMG=$INFILE
        ;;
        
        zip)
            IMG=$(zipinfo -1 $INFILE)  
        ;;
        
        xz)
            IMG=$(xz -l $INFILE | grep .xz | sed 's/\s\s*/ /g' | cut -d' ' -f10)
            IMG=$(echo $IMG | sed 's/.xz/.img/g')
         ;;   
         
         gz)
            IMG=$(pigz -l $INFILE | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4)
         ;;
         
         *)
            IMG=
        ;;
    esac
    
    
    if [ ! -z $(get_file_ext $IMG) ] && [ $(get_file_ext $IMG) = "img" ]; then
        echo $IMG [OK]
        return 0
    else
        echo "ERROR: No image found in '$INFILE'"
        return 1
    fi    
}


check_in_device_size_retired (){
    local INDEV=$1
    
   if [ $(get_sd_size_bytes $INDEV) -gt 16000000000 ]; then
        MESG=" '$INDEV' is larger than 16GB.  \
         \nUse a smaller SD card if you can, it will copy faster.\
         \nA good 8gb card in a Raspberry Pi 4 takes about 8 minutes"
         echo
        echo_red "WARNING... $MESG"   
    fi
}



check_out_device_size_retired (){
    local OUTDEV=$1
    local INTERFACE=$2
    
    # Check if SD-card is large... maybe the wrong device
    if [ $(get_sd_size_bytes $OUTDEV) -gt 16000000000 ]; then
        echo
        echo_red "WARNING... SD-card '$OUTDEV' '$(get_sd_name $OUTDEV)' is larger than 16GB... Are you sure it is the right device?"
        read -p "You must type 'BIG' to continue:"  -r RESULT
        if [ -z $RESULT ] || [ $RESULT != "BIG" ]; then
            echo Exiting...
            return 1
        fi
    fi
}


check_if_imagefile_will_fit_on_device_retired(){
    echo -n "Checking to see if image will fit on device..."
#echo $(get_image_size_bytes "$INFILE")
#echo $(get_sd_size_bytes "$OUTDEV")
    
    if [ $(get_image_size_bytes "$INFILE") -gt $(get_sd_size_bytes "$OUTDEV") ]; then
        echo
        echo_red ERROR... Image file is larger than SD-card.
        echo "Image size =$(get_image_size $INFILE)"
        echo "Device size=$(get_sd_size $OUTDEV)"
        return 1
    else
        echo [OK]
    fi
}


# -----------------------------------------------


do_list_info() {
        echo
        echo "CURRENT SYSTEM:"
        echo "Root disk = /dev/$(get_root_disk)"
        echo "FreeSpace = $(get_freespace)"
        echo "TrashSize = $(get_folder_size /home/pi/.local/share/Trash)"
        echo "RootTrash = $(get_folder_size /root/.local/share/Trash)"
        
        echo 
        echo "SD-CARD DEVICES (excluding root device):"
        echo "$(list_sd_devices)"

        echo   
        echo "IMAGE FILES:"
        ls -1 -s -h -w1 *.img *.zip *.xz *.gz 2> /dev/null | sed 's/ /     /'
}    

list_sd_devices() {
    local DEVICES=
    DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd?  2> /dev/null | grep -v $(get_root_disk) )   
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "${DEVICES[@]}"
  }

# --------------------------------------


get_tools() {   
    #echo -n Checking to see if required tools are installed ...
    
    if [ ! -f /usr/local/bin/pishrink.sh ] || [ ! -f /usr/bin/zip ] || [ ! -f /usr/bin/xz ] || [ ! -f /usr/bin/pigz ]  || [ ! -f /usr/bin/whiptail ] ; then
       
        read  -p "Install needed tools:  PiShrink, zip,  and xz-tools?" -n 1 -r RESULT
        echo

        if [ $RESULT = "y" ]; then
        
            # Install PiShrink if needed
            if [ ! -f /usr/local/bin/pishrink.sh ]; then
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                echo pishrink installed.
            fi

            # get zip if needed
            if [ ! -f /usr/bin/zip ]; then
                echo_white Installing zip...
                sudo apt install zip -y
            fi
            
            # get xz if needed
            if [ ! -f /usr/bin/xz ]; then
                echo_white Installing xz-utils...
                sudo apt install xz-utils -y
            fi
            
            # get gzip if needed
            if [ ! -f /usr/bin/pigz ]; then
                echo_white Installing pigz...
                sudo apt install pigz -y
            fi
            
            echo_white DONE installing tools. 
            
        else
            echo
            echo_red   WARNING.  Not all the needed tools are installed.
        fi
    fi
}    


do_install() {   
    echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    read  -p "Install $SCRIPTVER to /usr/local/bin [y,N]?" -n 1 -r RESULT
    echo
    
    if [ $RESULT = "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    else
        MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
        echo_or_msgbox "ERROR" "$MSG"
    fi
}


do_update() {
    
    INTERFACE=$1
    
    # this should not be needed.  the parameter should be passed.
    if [ -z $INTERFACE ]; then
        INTERFACE="gui"
    fi
      
    local SERVER_VER=
    rm $SCRIPTNAME.tmp
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/$SCRIPTNAME -O $SCRIPTNAME.tmp
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ];  then
        echo "ERROR: Can't connect to server..."
        return $EXIT_CODE
    fi    

    if [ -f $SCRIPTNAME.tmp ]; then
        SERVER_VER=$(bash $SCRIPTNAME.tmp -v)
    else
        return 1
    fi

    if [ $(get_ver_to_int $SERVER_VER) -gt $(get_ver_to_int $SCRIPTVER) ]; then
        read -p "Ver $SCRIPTVER.  Newer Version '$SERVER_VER' available.  Update [y,N]?"  -n 1 -r RESULT
        echo
        if [ $RESULT = "y" ]; then 
            sudo mv $SCRIPTNAME.tmp /usr/local/bin/$SCRIPTNAME
            sudo chmod +x /usr/local/bin/$SCRIPTNAME
            echo "$($SCRIPTNAME -v) installed"
        fi
    else    
        echo "Server version is '$SERVER_VER' You are up to date.  "
        if [ $INTERFACE = "gui" ]; then
            read -p "Press any key to continue..." -n 1 -r RESULT
        fi
    fi
}


do_backup(){
    local INDEV=$1
    local OUTFILE=$2
    local OUTFILE_BASE=$(get_file_base $OUTFILE)
    local OUTFILE_EXT=$(get_file_ext $OUTFILE)
    
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img
    
    echo_white $PRODUCTNAME Backup...
    echo "IN-DEV='$INDEV'"
    echo "OUT-FILE='$OUTFILE'"
        
    
    # check INDEV
    if [ -z $INDEV ] ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV' can't be blank"
        return 1
    fi 
    
    # add '/dev/' if missing
    if [ "${INDEV:0:5}" != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        INDEV="/dev/"$INDEV
        echo "IN-DEV='$INDEV'"
    fi
    
    # confirm INDEV exists
    if  [ ! -e $INDEV ]  ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV' not found"
        return 1
    fi 
    
    # warning if INDEV is root disk
    if [ $INDEV = /dev/$(get_root_disk) ]; then
        echo
        echo_red "WARNING: SD-card is root disk '/dev/$(get_root_disk)'."
        #return 1
    fi
    
    
    
    # Warning if SD-card is bigger than 16GB
    #check_in_device_size $INDEV
    #EXIT_CODE=$?
    #if [ $EXIT_CODE != 0 ] ; then
    #    echo WARNING $EXIT_CODE in check_in_device_size
    #    return $EXIT_CODE
    #fi
    if [ $(get_sd_size_bytes $INDEV) -gt 16000000000 ]; then
        MESG=" '$INDEV' is larger than 16GB.  \
         \nUse a smaller SD card if you can, it will copy faster.\
         \nA good 8gb card in a Raspberry Pi 4 takes about 8 minutes"
         echo
        echo_red "WARNING... $MESG"   
    fi
    
    
    
        
    
    # Stop if SD-card is bigger than freespace
    if [ $(get_sd_size_bytes $INDEV) -gt $(get_freespace_bytes) ]; then
        echo
        echo_red   "ERROR: Not enough free space on '$PWD'"
        return 1
    fi
    
    #warning if SD-card * 1.5 is bigger than freespace
        SPACENEEDED=$(( $(get_sd_size_bytes $INDEV) + $(( $(get_sd_size_bytes $INDEV) / 2 )) ))
        if [ $SPACENEEDED -gt $(get_freespace_bytes) ]; then
        echo
        echo_red   "WARNING: Might not be enough free space on '$PWD'"
        #return 1
    fi
    
    
    # check OUTFILE
    if [ -z $OUTFILE ] ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE' can't be blank"
        return 2
    fi  
    
    if [ -z $OUTFILE_EXT ]; then
        echo "No extension specified.  Adding '.zip'"
        OUTFILE=$OUTFILE.zip
        OUTFILE_EXT=$(get_file_ext $OUTFILE)
        echo "OUT-FILE='$OUTFILE'" 
    fi

    check_for_supported_file_extention
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red "ERROR: Unsupported file extension '$(get_file_ext $OUTFILE)'"
        return $EXIT_CODE 
    fi

    if  [ -f $OUTFILE ]  ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE' exists"
        return 2
    fi 

    if  [ -f $(get_file_base $OUTFILE).img ]  ; then
        echo
        echo_red "ERROR: OUT-FILE '$(get_file_base $OUTFILE).img' exists"
        return 2
    fi 

    
    
    # Final check before writing data
    if [ -z $INDEV ] || [ ! -e $INDEV ] ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV'.  Can't be blank.  Must exist."
        return 1
    fi 
    
    if [ -z $OUTFILE ] || [ -f $OUTFILE ] ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE'. Cant be blank. Can't exist. "
        return 2
    fi  

    #################################################
    # this section writes the data
    #################################################

    TIME1=$(date +%s)
    echo_white Step 1 of 3 - Reading  \'$INDEV\' to \'$OUTFILE_BASE.img\' ...
    date
    echo $(get_sd_size $INDEV ) to read
    sudo dd bs=4M if=$INDEV of=$OUTFILE_BASE.img status=progress conv=fsync 
    sleep 5s
    echo Done reading SD card
    echo_white $(ls -s -h $OUTFILE_BASE.img)
    TIME2=$(date +%s)  
    echo_white Step 1 took $(get_elapsed_time $TIME1 $TIME2)
    echo
   
    echo_white Step 2 of 3 - Shrinking filesystem with PiShrink ...
    sudo pishrink.sh $OUTFILE_BASE.img
    echo Done shrinking filesystem
    echo_white $(ls -s -h $OUTFILE_BASE.img)
    TIME3=$(date +%s)
    echo_white Step 2 took $(get_elapsed_time $TIME2 $TIME3)
    
    echo
    echo_white Step 3 of 3 - Compressing $OUTFILE_BASE.img to $OUTFILE ...
    date
    echo $SCRIPTNAME compression level set to $COMPRESSION of 9
   
    case $(get_file_ext $OUTFILE) in
        img)
            echo not compressing .img file ...
        ;;
        
        zip)
            local FILESIZE_M=$(( $(get_file_size_kbytes $OUTFILE_BASE.img) / 1024))
            local DOTSIZE=$(( $FILESIZE_M / 50 ))
            echo Each dot represents=$DOTSIZE MB
            echo -n "                      $(get_file_base $OUTFILE).img"
            echo ".........20........40........60........80........100%"
            zip -dbds $DOTSIZE -m -$COMPRESSION $OUTFILE $OUTFILE_BASE.img
        ;;
        
        xz)
            xz -z -v -T0 -$COMPRESSION $OUTFILE_BASE.img
            mv $OUTFILE_BASE.img.xz $OUTFILE
        ;;
        
        gz)
            pigz -v -$COMPRESSION $OUTFILE_BASE.img
            mv $OUTFILE_BASE.img.gz $OUTFILE
        ;;
        
        *)
            echo
            echo_red ERROR... unsupported file extension \'$(get_file_ext $OUTFILE)\'.
            return 1
        ;;
    esac
    
    echo Done compressing $OUTFILE_BASE.img to $OUTFILE
    echo_white $(ls -s -h $OUTFILE)
    TIME4=$(date +%s)
    echo_white  Step 3 took $(get_elapsed_time $TIME3 $TIME4)
    
    
    # check if $OUTFILE was created
    if [ ! -f $OUTFILE ]; then
        echo
        echo_red "ERROR: creating '$OUTFILE'"
        return 1
    fi
    
    echo
    echo_white "Backup done. '$OUTFILE' created from '$INDEV' in $(get_elapsed_time $TIME1 $TIME4)." 
}


do_restore(){
    local INFILE=$1
    local OUTDEV=$2
    
    echo_white $PRODUCTNAME Restore...
    echo "IN-FILE='$INFILE'"
    echo "OUT-DEV='$OUTDEV'"
    echo
    
    
    #check INFILE
    if [ -z $INFILE ] ; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank"
        return 1
    fi 
    
    if  [ ! -f $INFILE ]  ; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' not found "
        return 1
    fi 
    
    check_for_img_file $INFILE
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    
    
    # Stop if OUTDEV is blank
    if [ -z $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank"
        return 1
    fi
    
    # Add '/dev/' if missing
    if [ ${OUTDEV:0:5} != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        OUTDEV="/dev/"$OUTDEV
        echo "OUT-DEV='$OUTDEV'"
    fi
    
    # Stop if OUTDEV is not found
    if  [ ! -e $OUTDEV ]  ; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' not found"
        return 2
    fi 
    
    # Stop if restore to root disk.
    if [ $OUTDEV = /dev/$(get_root_disk) ]; then
        echo_red "ERROR: Restore to root disk '/dev/$(get_root_disk)' not allowed"
        return 1
    fi
    
    # Warning if device is big
    if [ $(get_sd_size_bytes $OUTDEV) -gt 16000000000 ]; then
        echo
        echo_red "WARNING... SD-card '$OUTDEV' '$(get_sd_name $OUTDEV)' is larger than 16GB... Are you sure it is the right device?"
        read -p "You must type 'BIG' to continue:"  -r RESULT
        if [ -z $RESULT ] || [ $RESULT != "BIG" ]; then
            echo Exiting...
            return 1
        fi
    fi
    
    # exit if image won't fit on device
   # check_if_imagefile_will_fit_on_device $INFILE $OUTFILE
   # EXIT_CODE=$?
   # if [ $EXIT_CODE != 0 ]; then
   #     return $EXIT_CODE
   # fi
    
    # Stop if image is bigger than device
    echo -n "Checking that Image file will fit on '$OUTDEV' ..."
    if [ $(get_image_size_bytes "$INFILE") -gt $(get_sd_size_bytes "$OUTDEV") ]; then
        echo
        echo_red ERROR... Image file is larger than SD-card.
        echo "Image size =$(get_image_size $INFILE)"
        echo "Device size=$(get_sd_size $OUTDEV)"
        return 1
    else
        echo [OK]
    fi
    


    # Final check before writing data
    if [ -z $INFILE ] || [ ! -e $INFILE ]; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank. must exist."
        return 1
    fi 
    
    if [ -z $OUTDEV ] || [ ! -e $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank.  must exist."
        return 1
    fi
    
    
    echo
    echo Write \'$INFILE\' to \'$OUTDEV\'?
    echo_red WARNING... All existing data on \'$OUTDEV\' - will be erased!
    read  -p "You must type 'YES' to continue:" -r RESULT
    echo
    
    if [ -z $RESULT ] || [ $RESULT != "YES" ]; then
        echo "You did not answer 'YES'"
        return 1
    fi
    
    
    # Safety timer
    do_beep_if_sound
    do_beep_if_sound
    
    sleep 1
    echo
    echo_red "WARNING '$OUTDEV' '$(get_sd_name $OUTDEV)' will be overwritten starting in 10 seconds ... Ctrl-C to abort"
    sleep 10
    
    
    #################################################
    # this section writes the data
    #################################################
    
    echo Unmounting SD-card $OUTDEV ...
    umount $OUTDEV?  2> /dev/null
    
    local INFILEEXT=$(get_file_ext $INFILE)
    
    echo        
    echo_white "Writing $INFILE to $OUTDEV ... "    
    date
    TIME1=$(date +%s)
    echo "$(get_image_size $INFILE) to write"
    
    case $INFILEEXT in
        img)
            sudo dd if=$INFILE of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;
        
        zip)
            unzip -p $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;
        
        xz)
            xz -v -d -c $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;

        gz)
            #pigz -v -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            pigz -v -k -c -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;

        *)
            echo
            echo_red ERROR.  Unsupported file extension. 
            return  1 
        ;;

    esac        
    TIME2=$(date +%s)
    echo
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        return $EXIT_CODE
    else
        echo_white "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
    fi
}


cli_menu(){
case $1 in
    
    backup|read)
        do_backup $2 $3
    ;;
    
    restore|write)
        do_restore $2 $3
    ;;
    
    list)
        do_list_info
    ;;
    
    install)
        do_install
    ;;
        
    update)
        do_update
    ;;
    
    help|-h)
        do_help
    ;;
    
    -v)
        echo $SCRIPTVER
    ;;
    
    gui)
        gui_menu
    ;;
    
    *)
        if [ ${SCRIPTNAME:0:6} = "pisafe" ]; then
            gui_menu
        else    
            do_help
        fi    
    ;;
esac
}






########################################
###  WHIPTAIL GUI SECTION ##############
########################################



calc_wt_size() {
  # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
  # output from tput. However in this case, tput detects neither stdout or 
  # stderr is a tty and so only gives default 80, 24 values

  WT_HEIGHT=18
  WT_HEIGHT_TALL=$(($(tput lines)-7))
  WT_WIDTH=$(tput cols)

  if [ -z "$WT_WIDTH" ] || [ "$WT_WIDTH" -lt 60 ]; then
    WT_WIDTH=80
  fi
  if [ "$WT_WIDTH" -gt 178 ]; then
    WT_WIDTH=80
  fi
  
  WT_WIDTH=80
  WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
  
  WT_MB_HEIGHT=20
  WT_MB_WIDTH=60
  
  # use for copy - paste
  # $WT_HEIGHT  $WT_WIDTH
  # $WT_MB_HEIGHT  $WT_MB_WIDTH
}


gui_update(){
    do_update "gui"
}


gui_install(){
    do_install
    
        # create the desktop file    

        echo "\
[Desktop Entry]
Type=Application
Terminal=true
Version=1.0
Name=$PRODUCTNAME
Comment=$PRODUCTCOMMENT
#Icon=rpi-imager
Icon=media-removable
Exec=lxterminal --geometry=110x40 -e $SCRIPTNAME
Categories=Utility
StartupNotify=false" > "$PRODUCTNAME.desktop"   

        sudo mv "$PRODUCTNAME.desktop" "/usr/share/applications"

        if [ -f "/usr/local/bin/$SCRIPTNAME" ]; then 
            MSG="$PRODUCTNAME $SCRIPTVER installed.            
            \nYou can execute it from any directory by typing '$SCRIPTNAME'.
            \nIt is easiest to start it from the directory that holds your image files.
            \nOr select it from the 'accessories' menu.  Note, this starts from the home directory."
            whiptail --backtitle "$BACKTITLE" --title "INSTALLED" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        else
            MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
            whiptail --backtitle "$BACKTITLE" --title "ERROR" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        fi
}


function gui_select_dr_file()
#
#  Arguments
#     1  Dialog title
#     2  Source path to list files and directories
#     3  File mask (by default *)
#     4  "yes" to allow go back in the file system.
#
#  Returns
#     0  if a file was selected and loads the FILE_SELECTED variable 
#        with the selected file.
#     1  if the user cancels.
#
#if dr_file_select "Please, select a file" /home/user ; then
#        echo "File Selected: \"$FILE_SELECTED\"."
#else
#        echo "Cancelled!"
#fi
# ----------------------------------------------------------------------
{
    # note: does not handle spaces in file names!!!
    local TITLE=${1:-$MSG_INFO_TITLE}
    local LOCAL_PATH=${2:-$(pwd)}
    local FILE_MASK=${3:-"*"}
    local FILE_MASK='( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" )'
    local ALLOW_BACK=${4:-no}
    local FILES=()
    FS="~"  # Field Seperator

    [ "$ALLOW_BACK" != "no" ] && FILES+=(".." "..")

  #  IFS=$'\n'

    # First add folders      
    # use std IFS for folders
    for DIR in $(find $LOCAL_PATH -maxdepth 1 -mindepth 1 -name "[!.]*" -type d -printf "%f " | sort 2> /dev/null)
    do
        FILES+=($DIR "folder")
    done



    # Then add the files
    # change IFS to newline.  Insert ~ as a field seperator 
IFS=$'\n'  
#IFS=$FS 
#unset IFS 
SKIPPED=0

# "saved:                                   -printf "%f$FS %sFS \n" | sort \"
    for FILE in $(find $LOCAL_PATH -maxdepth 1 \
                                    \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" \) \
                                    -name "[!.]*" \
                                    -type f \
                                    -printf "%f %k\n" | sort \
                                    2> /dev/null)
    do
        SPACES_IN_NAME=$(echo $FILE | sed '1s/[^ \t]//g' | wc -c) 
        if [ $SPACES_IN_NAME = 2 ]; then  # if no extra spaces in the filename
            FILES+=($FILE)
        else
       #     FILES+=($FILE )
       # i=$((i+1))
       echo "Skipped '$FILE' due to spaces in the name"
       SKIPPED=$((SKIPPED+1))
        fi
    done
unset IFS

echo SKIPPED=$SKIPPED
if [ $SKIPPED != 0 ] ; then
    whiptail --msgbox "$SKIPPED filenames with spaces were skipped" $WT_MB_HEIGHT $WT_MB_WIDTH
fi

    # sort the array
    #  IFS=$'\n' sorted=($(sort  <<<"${FILES[*]}")) ; unset IFS
    
#echo pre
#IFS=$FS
#echo ""${FILES[@]}""
#echo 
#echo "${FILES[@]}"
#echo loop
    # convert filesizes to mb
    re='^[0-9]+$'
    arraylength=${#FILES[@]}
#echo arraylength=$arraylength    
    for (( i=0; i<${arraylength}; i++ )); do
#echo -"${FILES[$i]}"-
            if [[ ${FILES[$i]} =~ $re ]] ; then
  #             # echo "error: Not a number" >&2; exit 1
                
                  FILES[$i]=$(echo $(( ${FILES[$i]} / 1024 / 1024 ))mb)
  x=1
            fi
#echo ""${FILES[$i]}""

    done
 
#IFS=$FS   
#IFS=$'\n' 

    # let user select file
    while true
    do
        FILE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$LOCAL_PATH" \
                                --menu "Choose a file" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT ""${FILES[@]}""  3>&1 1>&2 2>&3)

        #exit if bad whiptail statement
        FSX=${FILE_SELECTED:0:3}
        echo $FSX
        if [ ! -z $FSX ] && [ $FSX = "Box" ]; then
            echo "ERROR in whiptail in gui_select_dr_file.  Maybe a space in a filename?"
#echo ""${FILES[@]}""
#echo 
echo "${FILES[@]}"

            exit 1
        fi
        
        if [ -z "$FILE_SELECTED" ]; then
            return 1
        else
            if [ "$FILE_SELECTED" = ".." ] && [ "$ALLOW_BACK" != "no" ]; then
                return 0

            elif [ -d "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                if gui_select_dr_file "$TITLE" "$LOCAL_PATH/$FILE_SELECTED" "$FILE_MASK" "yes" ; then
                    if [ "$FILE_SELECTED" != ".." ]; then
                        return 0
                    fi
                else
                    return 1
                fi

            elif [ -f "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                FILE_SELECTED="$LOCAL_PATH/$FILE_SELECTED"
                return 0
            fi
        fi
    done
    
    unset IFS
}


gui_get_indev(){
    # for backup
    
    # Get global variables INDEV and OUTDEV
    gui_select_sddevice  
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then 
        return $EXIT_CODE
    fi    
    
    # Warning if INDEV is root disk
    if [ $INDEV = /dev/$(get_root_disk) ]; then
        whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "SD-card is your root disk." $WT_MB_HEIGHT $WT_MB_WIDTH  
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(get_sd_size_bytes $INDEV) -gt 16000000000 ]; then
        MESG=" '$INDEV' is larger than 16GB.  \
         \nUse a smaller SD card if you can, it will copy faster\
         \nbecause it has to 'copy the entire SD card' before it can compress it.\
         \nA good 8gb card in a Raspberry Pi 4 takes about 8 minutes"
        whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "$MESG" $WT_MB_HEIGHT $WT_MB_WIDTH   
    fi
    
    # Stop if SD-card is bigger than freespace
    if [ $(get_sd_size_bytes $INDEV) -gt $(get_freespace_bytes) ]; then
        whiptail --backtitle "$BACKTITLE" --title "ERROR" --msgbox "Not enough free space on '$PWD'" $WT_MB_HEIGHT $WT_MB_WIDTH 
        return 1
    fi
    
    # Warning if one and a half times the SD-card is bigger than freespace
    SPACENEEDED=$(( $(get_sd_size_bytes $INDEV) + $(( $(get_sd_size_bytes $INDEV) / 2 )) ))
    if [ $SPACENEEDED -gt $(get_freespace_bytes) ]; then
        whiptail --backtitle "$BACKTITLE" --title "WARNING" \
            --msgbox "Might not be enough free space on '$PWD'
            \nThere are $(get_folder_size /home/pi/.local/share/Trash) in the Trash" $WT_MB_HEIGHT $WT_MB_WIDTH   
    fi
    
    # maybe check and see if it looks like a raspbian disk?
}


gui_get_outfile(){
    # for backup
    
    OUTFILE_BASE=$(get_file_base $OUTFILE)
    OUTFILE_EXT=$(get_file_ext $OUTFILE)
    check_for_supported_file_extention
    EXT_OK=$?
    OUTFILEDEFAULT=$(date +%Y-%m-%d-newimage)
           
    while [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] || [ -f "$OUTFILE_BASE.img" ] || [ "$EXT_OK" = "1" ]; do  
        
        # if no extension, add .zip
        if [ ! -z $OUTFILE ] && [ -z "$OUTFILE_EXT" ]; then
            OUTFILE=$OUTFILE.zip
            OUTFILE_BASE=$(get_file_base $OUTFILE)
            OUTFILE_EXT=$(get_file_ext $OUTFILE)
        fi
        
        # Message if OUTFILE exists
        if [ -f "$OUTFILE" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "File '$OUTFILE' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        # Message if OUTFILE.img exists
        if [ -f "$OUTFILE_BASE.img" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "File '$OUTFILE_BASE.img' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        if [ "$EXT_OK" = "1" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "Unsupported extention '$(get_file_ext $OUTFILE)' " $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        
        #get filename
        MSG="Enter the filename (eg 2020-12-15-Buster32) 
        \nSupported extensions are: .img .zip .xz .gz 
        \nIf you don't include an extension '.zip' will be added. "
        NEWFILE=$(whiptail --backtitle "$BACKTITLE" --title "BACKUP : Get Filename" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$OUTFILEDEFAULT" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then 
            return $EXIT_CODE
        fi
        
        #fill out variables based on selected filename
        OUTFILEDEFAULT=$NEWFILE
        OUTFILE=$NEWFILE
        OUTFILE_BASE=$(get_file_base $OUTFILE)
        if [ -z $(get_file_ext $OUTFILE) ] ; then 
             OUTFILE=$OUTFILE.zip
        fi
        #OUTFILE_EXT=$(get_file_ext $OUTFILE)
        #EXT_OK=$(check_for_supported_file_extention && echo $?)
        check_for_supported_file_extention
        EXT_OK=$?
        
      done      
}


gui_get_infile(){
    # for restore
    
    if gui_select_dr_file "WRITE : Select an Image-file" "" "" "no" ; then
    INFILE=$FILE_SELECTED
    else
        #echo "Backup cancelled"
        return 1
    fi
     
    check_for_img_file $INFILE
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No image file found in '$INFILE'"  $WT_MB_HEIGHT $WT_MB_WIDTH
        return $EXIT_CODE
    fi 
}


gui_get_outdev(){
    # for restore

    gui_select_sddevice        # this sets global variable OUTDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi    
    
    
    
    # Stop if outdev is the root disk
    if [ $OUTDEV = /dev/$(get_root_disk) ]; then
        #echo "ERROR: Restore to root disk '/dev/$(get_root_disk)' not allowed"
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "Restore to root drive not allowed" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
    

    # Warning if device is larger than 16GB
    # note the RESULT is not used here... could be cleaned up
    if [ $(get_sd_size_bytes $OUTDEV) -gt 16000000000 ]; then
        if (whiptail  --backtitle "$BACKTITLE" --title RESTORE-WARNING --defaultno \
            --yesno "WARNING... SD-card '$OUTDEV' '$(get_sd_name $OUTDEV)' is larger than 16GB... Are you sure it is the right device?" $WT_HEIGHT $WT_WIDTH) then
            RESULT="YES"
        else
            RESULT="n"
            return 1
        fi
    fi
     
    # Stop if imagefile is bigger than device
    if [ $(get_image_size_bytes "$INFILE") -gt $(get_sd_size_bytes "$OUTDEV") ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "Image '$INFILE' is bigger than device '$OUTDEV'" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
}


gui_do_backup(){
    INDEV=$1  #use global vars  
    OUTFILE=$2   #use global vars
    local OUTFILE_BASE=$(get_file_base $OUTFILE)
    local OUTFILE_EXT=$(get_file_ext $OUTFILE)
    
    #get global variable INDEV
    gui_get_indev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    # get global variable OUTFILE
    gui_get_outfile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    #confirm to continue
    whiptail  --backtitle "$BACKTITLE" --title "BACKUP : Create Image-file" --defaultno \
        --yesno "Create image-file '$OUTFILE' from '/dev/$INDEV'  
        \nA good 8GB card on a Pi4 takes about 9 minutes.
        \nThis will switch to terminal screen to watch the progress ...
        \n\nAre you sure you want to continue?"   $WT_HEIGHT $WT_WIDTH
    EXIT_CODE=$?       
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi


    ###########################################################
    # this next line actually does the work!!
    do_backup $INDEV $OUTFILE "gui"
    EXIT_CODE=$?
    read -n 1 -p "Press any key to continue..." 
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi
    ###########################################################

    # Display results
    whiptail  --backtitle "$BACKTITLE" --title " BACKUP-DONE "  \
        --msgbox "Done creating imagefile '$OUTFILE'
        \nfrom '$(get_sd_name $INDEV)' 
        \ncompressed from '$(get_sd_size $INDEV)' to '$(get_file_size $OUTFILE)' in $(get_elapsed_time $TIME1 $TIME4) 
        \n\nYou can remove '$(get_sd_name $INDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}  


gui_do_restore() {
    #get parameters
    #INFILE=$1
    #OUTDEV=$2
    
    # get global variable INFILE
    gui_get_infile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    # get global variable OUTDEV
    gui_get_outdev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi

    # Confirm to continue
    if (whiptail  --backtitle "$BACKTITLE" --title RESTORE-WARNING --defaultno \
        --yesno "Write image '$INFILE' \nto SD card  '$OUTDEV'   '$(get_sd_name $OUTDEV)'
        \nThis will switch to a terminal screen to watch the progress ... There are currently some safety prompts in the terminal screen.
        \n\nALL existing data on '/dev/$OUTDEV' - WILL BE ERASED!  
        \n\nAre you sure you want to continue?" $WT_HEIGHT $WT_WIDTH) then
        #echo "User selected Yes, exit status was $?."
        RESULT="YES"
    else
        #echo "User selected No, exit status was $?."
        RESULT="n"
        return 1
    fi

              
   ###################################################       
    # do the restore
    do_restore $INFILE $OUTDEV  
    EXIT_CODE=$?
    read -n 1 -p "Press any key to continue..." 
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi    
   ###################################################
 
    #display the results
    whiptail  --backtitle "$BACKTITLE" --title " RESTORE-DONE " \
        --msgbox "Done writing '$INFILE' 
        \nto '$(get_sd_name $OUTDEV)'
        \nin $(get_elapsed_time $TIME1 $TIME2)
        \n\nYou can remove '$(get_sd_name $OUTDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}


gui_select_sddevice(){
    FIELD_SEPERATOR="|"

    #get this list of sd divices and add a field seperator |    
    IFS=$'\n'
    #options=($(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ ./ | /'))
    options=($(list_sd_devices | sed 's/ ./ '$FIELD_SEPERATOR' /'))
    unset IFS
    if [ -z  "${options[@]}" ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No SD cards found." $WT_HEIGHT_TALL  $WT_WIDTH
        return 1
    fi

    IFS=$FIELD_SEPERATOR
    DEVICE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "SD cards" --menu "Choose an an SD card" 30 80 10 ""${options[@]}"" 3>&1 1>&2 2>&3)
    EXIT_CODE=$?
    unset IFS   
     
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    OUTDEV=/dev/$DEVICE_SELECTED
    INDEV=/dev/$DEVICE_SELECTED
    return 0
}


gui_menu(){
    calc_wt_size
    INTERFACE="GUI"
    while true
    do
        MENU_CHOICE=$(whiptail \
                --clear \
                --backtitle "$BACKTITLE" \
                --title "MAIN MENU" \
                --ok-button "Select" \
                --cancel-button "Exit" \
                --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "BACKUP"      "   Backup an SD-card to an image-file " \
                "RESTORE"     "   Restore an SD-card from an image-file" \
                "LIST"      "   List info " \
                "OPTIONS"   "   Set options " \
                "INSTALL"   "   Install into the menu" \
                "HELP"      "   Help " \
                "ABOUT"     "   About " \
                "UPDATE"    "   Check for updates " \
                 3>&1 1>&2 2>&3)
        
        #echo $MENU_CHOICE
        case $MENU_CHOICE in
            BACKUP)
                gui_do_backup
            ;;
            
            RESTORE)
                gui_do_restore
            ;;
            
            LIST)
                INFO=$(do_list_info)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "LIST" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
            ;;
            
            OPTIONS)
                gui_options
            ;;
            
            
            INSTALL)
                gui_install
            ;;
            
             HELP)
                INFO=$(do_help)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
            ;;
            
            ABOUT)
                INFO=$(do_about)
                 result="$INFO"
                 whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
            ;;   
            
            UPDATE)
                do_update
            ;;
            
            *)
                return
            ;;
        esac
    done
}

testing(){
    #testing
    #echo $(( $(zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2) / 1024 / 1024 ))M
    INDEV="/dev/sda"
    HALF_SD_SIZE=$(( $(get_sd_size_bytes $INDEV) / 2 ))
    ONE_AND_HALF_SD_SIZE=$(( $(get_sd_size_bytes $INDEV) + $HALF_SD_SIZE ))
    
    echo $(get_sd_size_bytes $INDEV)
    echo $HALF_SD_SIZE
       echo $ONE_AND_HALF_SD_SIZE
       
    echo $(( $(get_sd_size_bytes $INDEV) + $(( $(get_sd_size_bytes $INDEV) / 2 )) ))
    SPACENEEDED=$(( $(get_sd_size_bytes $INDEV) + $(( $(get_sd_size_bytes $INDEV) / 2 )) ))
    echo $SPACENEEDED

    exit
    #testing
}

# if arg = -v, then show version and exit the script
if  [ ! -z "$1" ]  && [ $1 = "-v" ]; then
    echo $SCRIPTVER
    exit
fi

get_tools

#testing
#exit


cli_menu $1 $2 $3
