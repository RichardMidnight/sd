#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021"

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room

SCRIPTNAME="${0##*/}"
SCRIPTVER="1.7.0"
PRODUCTNAME="sd"
PRODUCTCOMMENT="Backup-to or Restore-from an Image File"
CURRENT_DIR=$(pwd)

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }


#INDEV=
#OUTDEV=
#SDDEV=
#INFILE=
#OUTFILE=


do_help() {
    echo "$PRODUCTNAME v$SCRIPTVER  - Designed for Raspberry Pi"
    echo " - Backup your SD card to an image file"
    echo " - Restore your SD card from an image file"
    echo
    echo "Usage: "
    echo "  $SCRIPTNAME [function] [xxx] [yyy]"
    echo
    echo "Function is:"
    echo "  list                      - list SD-devices and image-files "
    echo "  backup [device] [file]    - backup SD-card to image-file"
    echo "  restore [file] [device]   - restore image-file to SD-card"
    echo "  install                   - install this script"
    echo "  update                    - update script from webiste"
    echo "  -v                        - display version"
    echo "  help | -h                 - help"
    echo
    echo "Notes: "
    echo " - Supports .img .zip .xz and .gz files.  Appends '.zip' if no extension is specified "
    echo " - Specifying a '.img' extension is faster, but larger.  It is shrunk with PiShrink but not compressed with zip."
    echo " - Prepends '/dev/' to device if not specified"
    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Examples:"
    echo $SCRIPTNAME list
    echo $SCRIPTNAME backup sda newimage
    echo $SCRIPTNAME backup /dev/sdb newimage.xz
    echo $SCRIPTNAME restore newimage.zip sda
    echo
}


do_about(){
    echo "$PRODUCTNAME was started in 2017 by Richard Reed (github RichardMidnight)"\
        "when he was working on a Raspberry Pi Homebrdge project and needed"\
        "to make numerous restore-points.  The image writers available at the"\
        "time were not able to create a new image file" 
    echo
    echo "It was origionally called 'sd' to simplify command-line-usage."
    echo
    echo "Then in 2021, I added the graphical front-end to make it more usable by others"\
        "and renamed it 'Pi Safe' with is a reference to the ventilated cupboards that would let"\
        "you 'save a pie for later' "
    echo
    echo "I hope this is helpful to others."
    echo
}


get_file_base() {
    local fullfilename=$1
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo $fname
}


get_file_ext() {
    local fullfilename=$1
    
    filename=$(basename "$fullfilename")
    ext="${filename##*.}"
    if [ $ext == $(get_file_base $filename) ]; then
      ext=""
    fi
    echo $ext
}


get_file_size_kbytes() {
    local FILE=$1
    
    if [ -f $FILE ] ; then
        ls -s $FILE | cut -d' ' -f1
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_image_size_bytes() {
    local INFILE=$1
    
    case $(get_file_ext $INFILE) in
        img)
            echo $((  $(ls -s $INFILE | cut -d' ' -f1) * 1024 )) 
        ;;
        
        zip)
            zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2
        ;;
        
        xz)
            xz -l -v $INFILE | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1
        ;;  
          
        gz)
            pigz -l $INFILE | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g'
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
}    


get_boot_disk() {
    local BOOT_PARTITION
    local BOOT_DRIVE
    
    BOOT_PARTITION=$(lsblk -l | grep "/$" | cut -d' ' -f1 2> /dev/null) 
    
    if [ -z $BOOT_PARTITION ]; then
        return 1  # can't find boot partition or boot drive
    fi
    
    if [[ $BOOT_PARTITION =~ "p" ]]; then
        BOOT_DRIVE=$(echo $BOOT_PARTITION | cut -d'p' -f1)
    elif [[ $BOOT_PARTITION =~ "sd" ]]; then
        BOOT_DRIVE=${BOOT_PARTITION:0:3}
    else
        return 2  # can't find boot disk
    fi    
    echo $BOOT_DRIVE
}


get_freespace() {
    local RET
    RET=$(df . -h --output=avail | grep -v Avail)
    
    echo $RET
}    


get_folder_size() {
    local FOLDER=$1
    
    if [ -d $FOLDER ] ; then
        sudo du -sh $FOLDER | cut -d'/' -f1 | sed 's/\s\s*/ /g'
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_sd_size_bytes() {
    INDEV=$1
    local BYTES
    
    BYTES=$(lsblk "$INDEV" -d -n -b -o size )
#echo $BYTES    
    
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE       
    fi
    
     echo $BYTES
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


get_ver_to_int() {
	# this is not currently used... but clever
	local IFS=.
	parts=($1)
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
       
    OUTFILE_EXT=$(get_file_ext $OUTFILE)

    case $OUTFILE_EXT in
        img | zip | xz | gz |"" )
            return 0
        ;;
        
        *)  
            return 1
        ;;
    esac
}


check_for_img_file(){
    INFILE=$1
    
    echo -n "Inspecting '$INFILE' for an image file ... "
 
    case $(get_file_ext $INFILE) in
        img)
            IMG=$INFILE
        ;;
        
        zip)
            IMG=$(zipinfo -1 $INFILE)  
        ;;
        
        xz)
            IMG=$(xz -l $INFILE | grep .xz | sed 's/\s\s*/ /g' | cut -d' ' -f10)
            IMG=$(echo $IMG | sed 's/.xz/.img/g')
         ;;   
         
         gz)
            IMG=$(pigz -l $INFILE | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4)
         ;;
         
         *)
            IMG=
        ;;
    esac
    
    
    if [ ! -z $(get_file_ext $IMG) ] && [ $(get_file_ext $IMG) = "img" ]; then
        echo $IMG [OK]
        return 0
       # fi
    else
        echo "ERROR: No image found in '$INFILE'"
        return 1
    fi    
}


check_in_device_size (){
    local INDEV=$1
    
#echo $(get_sd_size_bytes $INDEV)
# exit
    
   if [ $(get_sd_size_bytes $INDEV) -gt 16000000000 ]; then
        MESG=" '$INDEV' is larger than 16GB.  \
         \nUse a smaller SD card if you can, it will copy faster.\
         \nA good 8gb card in a Raspberry Pi 4 takes about 8 minutes"
        echo_red "WARNING... $MESG"
#exit        
        
    fi
}



check_out_device_size (){
    # Check if SD-card is large... maybe the wrong device
    #if (( $(get_sd_size_bytes $OUTDEV) > 16000000000 )); then
    

    
    if [ $(get_sd_size_bytes $OUTDEV) -gt 16000000000 ]; then
        echo
        echo_red WARNING... SD-card \'$(get_sd_card_name  $OUTDEV)\' is larger than 16GB... Are you sure it is the right device?
        #echo "$OUTDEV size=$(get_sd_size $OUTDEV)"
        read -p "You must type 'OK' to continue:"  -r RESULT
        if [ $RESULT != "OK" ]; then
            echo Exiting...
            return 1
        fi
    fi
}


check_if_imagefile_will_fit_on_device(){
    echo -n "Checking to see if image will fit on device..."
    if [ $(get_image_size_bytes "$INFILE") -gt $(get_sd_size_bytes "$OUTDEV") ]; then
        echo
        echo_red ERROR... Image file is larger than SD-card.
        echo "Image size =$(get_image_size $INFILE)"
        echo "Device size=$(get_sd_size $OUTDEV)"
    else
        echo [OK]
    fi
}


list_info() {
        echo
        echo_white "CURRENT SYSTEM:"
        echo "Boot disk = /dev/$(get_boot_disk)"
        echo "FreeSpace = $(get_freespace)"
        echo "TrashSize = $(get_folder_size /home/pi/.local/share/Trash)"
        echo "RootTrash = $(get_folder_size /root/.local/share/Trash)"
        
        echo 
        echo_white "SD-CARD DEVICES (excluding boot device):"
        lsblk -d -n -p -o NAME,VENDOR,MODEL,SIZE /dev/sd?  2> /dev/null | grep -v $(get_boot_disk)
        #echo "$(list_sd_devices)"

        echo   
        echo_white "IMAGE FILES:"
        ls -1 -s -h -w1 *.img *.zip *.xz *.gz 2> /dev/null | sed 's/ /     /'
}    



# --------------------------------------


get_tools() {   
    #echo -n Checking to see if required tools are installed ...
    
    if [ ! -f /usr/local/bin/pishrink.sh ] || [ ! -f /usr/bin/zip ] || [ ! -f /usr/bin/xz ] || [ ! -f /usr/bin/pigz ]  || [ ! -f /usr/bin/whiptail ] ; then
       
        read  -p "Install needed tools:  PiShrink, zip,  and xz-tools?" -n 1 -r RESULT
        echo

        if [ $RESULT = "y" ]; then
        
            # Install PiShrink if needed
            if [ ! -f /usr/local/bin/pishrink.sh ]; then
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                echo pishrink installed.
            fi

            # get zip if needed
            if [ ! -f /usr/bin/zip ]; then
                echo_white Installing zip...
                sudo apt install zip -y
            fi
            
            # get xz if needed
            if [ ! -f /usr/bin/xz ]; then
                echo_white Installing xz-utils...
                sudo apt install xz-utils -y
            fi
            
            # get gzip if needed
            if [ ! -f /usr/bin/pigz ]; then
                echo_white Installing pigz...
                sudo apt install pigz -y
            fi
            
            echo_white DONE... 
            
        else
            echo_red   WARNING.  Not all the needed tools are installed.
        fi
    fi
}    


do_install() {   
    echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    read  -p "Install $SCRIPTVER to /usr/local/bin [y,N]?" -n 1 -r RESULT
    echo
    
    if [ $RESULT = "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    else
        MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
        echo_or_msgbox "ERROR" "$MSG"
    fi
}


do_update(){
    local SERVER_VER=
    rm $SCRIPTNAME.tmp
    wget https://raw.githubusercontent.com/RichardMidnight/sd/main/$SCRIPTNAME -O $SCRIPTNAME.tmp
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ];  then
        echo "ERROR: Can't connect to server..."
        return $EXIT_CODE
    fi    

    if [ -f $SCRIPTNAME.tmp ]; then
        SERVER_VER=$(bash $SCRIPTNAME.tmp -v)
    else
        return 1
    fi

    if [ $(get_ver_to_int $SERVER_VER) -gt $(get_ver_to_int $SCRIPTVER) ]; then
        read -p "Ver $SCRIPTVER.  Newer Version '$SERVER_VER' available.  Update [y,N]?"  -n 1 -r RESULT
        echo
        if [ $RESULT = "y" ]; then 
            sudo mv $SCRIPTNAME.tmp /usr/local/bin/$SCRIPTNAME
            sudo chmod +x /usr/local/bin/$SCRIPTNAME
            echo "$($SCRIPTNAME -v) installed"
        fi
    fi
}


do_backup(){
    local INDEV=$1
    local OUTFILE=$2
    local OUTFILE_BASE=$(get_file_base $OUTFILE)
    local OUTFILE_EXT=$(get_file_ext $OUTFILE)
    COMPRESSION=1
    
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img
    
    echo_white $PRODUCTNAME Backup...
    echo "IN-DEV='$INDEV'"
    echo "OUT-FILE='$OUTFILE'"
        
    
    # check INDEV
    if [ -z $INDEV ] ; then
        echo_red "ERROR: IN-DEV '$INDEV' can't be blank"
        return 1
    fi 
    
    if [ "${INDEV:0:5}" != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/"
        INDEV="/dev/"$INDEV
        echo "IN-DEV='$INDEV'"
    fi
    
    if  [ ! -e $INDEV ]  ; then
        echo_red "ERROR: IN-DEV '$INDEV' not found"
        return 1
    fi 
    
    # Warning if SD-card is bigger than 16GB
    check_in_device_size $INDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then
        echo WARNING $EXIT_CODE in check_in_device_size
        return $EXIT_CODE
    fi    
    
  
    
    
    # check OUTFILE
    if [ -z $OUTFILE ] ; then
        echo_red "ERROR: OUT-FILE '$OUTFILE' can't be blank"
        return 2
    fi  
    
    if [ -z $OUTFILE_EXT ]; then
        echo "No extension specified.  Adding '.zip'"
        OUTFILE=$OUTFILE.zip
        OUTFILE_EXT=$(get_file_ext $OUTFILE)
        echo "OUT-FILE='$OUTFILE'" 
    fi

    check_for_supported_file_extention
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo_red "ERROR: unsupported file extension '$(get_file_ext $OUTFILE)'"
        return $EXIT_CODE 
    fi

    if  [ -f $OUTFILE ]  ; then
        echo_red "ERROR: OUT-FILE '$OUTFILE' exists"
        return 2
    fi 


    
    
    # Final check before running
    if [ -z $INDEV ] || [ ! -e $INDEV ] ; then
        echo_red "ERROR: IN-DEV '$INDEV' .  Can't be blank.  Must exist."
        return 1
    fi 
    
    if [ -z $OUTFILE ] || [ -f $OUTFILE ] ; then
        echo_red "ERROR: OUT-FILE '$OUTFILE' . Cant be blank. Can't exist. "
        return 2
    fi  


    TIME1=$(date +%s)
    echo_white Step 1 of 3 - Reading  \'$INDEV\' to \'$OUTFILE_BASE.img-tmp\' ...
    date
    #echo $(get_sd_size $INDEV ) to read
    sudo dd bs=4M if=$INDEV of=$OUTFILE_BASE.img-tmp status=progress conv=fsync 
    sleep 5s
    echo Done reading SD card
    echo_white $(ls -s -h $OUTFILE_BASE.img-tmp)
    TIME2=$(date +%s)  
    echo_white Step 1 took $(get_elapsed_time $TIME1 $TIME2)
    echo
   
    echo_white Step 2 of 3 - Shrinking filesystem with PiShrink ...
    sudo pishrink.sh $OUTFILE_BASE.img-tmp
    echo Done shrinking filesystem
    echo_white $(ls -s -h $OUTFILE_BASE.img-tmp)
    TIME3=$(date +%s)
    echo_white Step 2 took $(get_elapsed_time $TIME2 $TIME3)
    
    echo
    echo_white Step 3 of 3 - Compressing $OUTFILE_BASE.img-tmp to $OUTFILE ...
    date
    #echo Compression level set to $COMPRESSION out of -9
    echo $SCRIPTNAME compression level set to $(echo $COMPRESSION | sed 's/-/ /g') of 9
   
    case $(get_file_ext $OUTFILE) in
        img)
            echo not compressing .img file ...
            mv $OUTFILE_BASE.img-tmp $OUTFILE
        ;;
        
        zip)
            local FILESIZE_M=$(( $(get_file_size_kbytes $OUTFILE_BASE.img-tmp) / 1024))
            local DOTSIZE=$(( $FILESIZE_M / 50 ))
            echo Dot size=$DOTSIZE MB
            echo -n "                      $(get_file_base $OUTFILE).img-tmp"
            echo ".........20........40........60........80........100%"
            zip -dbds $DOTSIZE -m -$COMPRESSION $OUTFILE $OUTFILE_BASE.img-tmp
        ;;
        
        xz)
            xz -z -v -T0 -$COMPRESSION $OUTFILE_BASE.img-tmp
            mv $OUTFILE_BASE.img-tmp.xz $OUTFILE
        ;;
        
        gz)
            pigz -v -$COMPRESSION $OUTFILE_BASE.img-tmp
            mv $OUTFILE_BASE.img-tmp.gz $OUTFILE
        ;;
        
        
        *)
            echo_red ERROR... unsupported file extension \'$(get_file_ext $OUTFILE)\'.
            return 1
        ;;
    esac
    
    echo Done compressing $OUTFILE_BASE.img-tmp to $OUTFILE
    echo_white $(ls -s -h $OUTFILE)
    TIME4=$(date +%s)
    echo_white  Step 3 took $(get_elapsed_time $TIME3 $TIME4)
    
    
    # check if $OUTFILE was created
    if [ ! -f $OUTFILE ]; then
        echo_red "ERROR: creating '$OUTFILE'"
        return 1
    fi
    
    echo
    echo_white "Backup done. '$OUTFILE' created in $(get_elapsed_time $TIME1 $TIME4)." 
}


do_restore(){
    local INFILE=$1
    local OUTDEV=$2
    
    echo_white $PRODUCTNAME Restore...
    echo "IN-FILE='$INFILE'"
    echo "OUT-DEV='$OUTDEV'"
    echo
    
    
    #check INFILE
    if [ -z $INFILE ] ; then
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank"
        return 1
    fi 
    
    if  [ ! -f $INFILE ]  ; then
        echo_red "ERROR: can't find IN-FILE '$INFILE' "
        return 1
    fi 
    
    check_for_img_file $INFILE
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    
    
    # check OUTDEV
    if [ -z $OUTDEV ]; then
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank"
        return 1
    fi
    
    if [ ${OUTDEV:0:5} != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        OUTDEV="/dev/"$OUTDEV
        echo "OUT-DEV='$OUTDEV'"
    fi
    
    if  [ ! -e $OUTDEV ]  ; then
        echo_red "ERROR: Can't find OUT-DEV '$OUTDEV' "
        return 2
    fi 
    
    check_out_device_size $OUTDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    check_if_imagefile_will_fit_on_device $INFILE $OUTFILE
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi



    # final check before running
    if [ -z $INFILE ] || [ ! -e $INFILE ]; then
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank. must exist."
        return 1
    fi 
    
    if [ -z $OUTDEV ] || [ ! -e $OUTDEV ]; then
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank.  must exist."
        return 1
    fi
    
    
    
    echo
    echo Write \'$INFILE\' to \'$OUTDEV\'?
    echo_red WARNING... All existing data on \'$OUTDEV\' - will be erased!
    read  -p "You must type 'YES' to continue:" -r RESULT
    echo
    
    if [ -z $RESULT ] || [ $RESULT != "YES" ]; then
        echo "You did not answer 'YES'"
        return 1
    fi
    
    
    echo Unmounting SD-card $OUTDEV ...
    umount $OUTDEV?  2> /dev/null
    
    date
    TIME1=$(date +%s)

    local INFILEEXT=$(get_file_ext $INFILE)
    
    echo        
    echo_white "Writing $INFILE to $OUTFILE ... "    
    
    case $INFILEEXT in
        img)
            sudo dd if=$INFILE of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;
        
        zip)
            unzip -p $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;
        
        xz)
            xz -v -d -c $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;

        gz)
            pigz -v -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            EXIT_CODE=$?
        ;;

        *)
            echo_red ERROR.  Unsupported file extension. 
            return  1 
        ;;

    esac        
    TIME2=$(date +%s)
    echo
    
    if [ $EXIT_CODE != 0 ]; then
        echo_red  "ERROR. $EXIT_CODE"
        return $EXIT_CODE
    else
        echo_white "Restore done. Total time $(get_elapsed_time $TIME1 $TIME2)."
    fi
}


# if arg = -v, then show version and exit the script
if  [ ! -z "$1" ]  && [ $1 = "-v" ]; then
    echo $SCRIPTVER
    exit
fi

get_tools

case $1 in
    
    backup|read)
        do_backup $2 $3
    ;;
    
    restore|write)
        do_restore $2 $3
    ;;
    
    list)
        list_info
    ;;
    
    install)
        do_install
    ;;
        
    update)
        do_update
    ;;
    
    help|-h)
        do_help
    ;;
    
    -v)
        echo $SCRIPTVER
    ;;
    
    *)
        do_help
        #this could be gui_menu sometime...
    ;;
esac



