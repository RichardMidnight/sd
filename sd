#!/bin/bash

# by Richard Reed 2018 - 2020

SD_VER="1.5.9"
CURRENT_DIR=$(pwd)
SCRIPTNAME="${0##*/}"


# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room


WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }



help() {
    echo "Raspberry pi image-file reader-writer ver $SD_VER (2020)."
    echo "This will  read an SD card to an image file"
    echo "or         write an image file to an SD card"
    echo
    echo "Supports .img .zip .xz and .gz files"
    echo "Naming an image-file with a '.img' extension is faster, but larger.  It is shrunk with PiShrink but not compressed with zip."
    echo "Defaults to .zip if no extension is specified"

    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Usage: "
    echo "sd list            (to list sd devices and image files)"
    echo "sd write [file] [device]"
    echo "sd read [device] [file]"
    echo "sd install         (to install this script into /usr/local/bin/sd)"
    echo
    echo "Examples:"
    echo sd read sda newimage.zip
    echo sd read sdb newimage.xz
    echo sd write newimage.zip sda
    echo
}



sd_size() {
    #get parameters
    INDEV=$1
    lsblk /dev/$INDEV -d -n -o size  2> /dev/null
    if ! [ $? == 0 ]; then
        echo 0
    fi
}



sd_size_bytes() {
    #get parameters
    INDEV=$1
    lsblk /dev/$INDEV -d -n -b -o size  2> /dev/null
    if ! [ $? == 0 ]; then
        echo 0
    fi
}



image_size() {
    #get parameters
    INFILE=$1
    
    case $(file_ext $INFILE) in
        img)
            ls -s -h $INFILE | cut -d' ' -f1
        ;;
        
        zip)
            echo $(( $(zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2) / 1024 / 1024 )) MB
        ;;
        
        xz)
            xz -l $INFILE | grep -v Strms | cut -c28-40
        ;;    
        
        gz)
            pigz -l t$INFILE | grep -v compressed | cut -d' ' -f2
        ;;
    esac
}



image_size_bytes() {
    #get parameters
    INFILE=$1
    
    case $(file_ext $INFILE) in
        img)
            echo $((  $(ls -s $INFILE | cut -d' ' -f1) * 1024 )) 
        ;;
        
        zip)
            zipinfo -t $INFILE | cut -d, -f2 | cut -d" " -f2
        ;;
        
        xz)
            xz -l -v $INFILE | grep Uncompressed | cut -d' ' -f8 | cut -d"(" -f2 | sed -e 's/,//g'
        ;;  
          
        gz)
            # note probably needs to be converted to MB
            #pigz -l $INFILE | grep -v compressed | cut -d' ' -f2
            echo $(($(pigz -l $INFILE | grep -v compressed | cut -d' ' -f2) / 1024 / 1024 )) MB
        ;;
    esac
}    



freespace() {
    echo $(df . -h --output=avail | grep -v Avail)
}    

freespace_bytes() {
    echo $(df . -B1 --output=avail | grep -v Avail)
}    



file_base() {
    fullfilename=$1
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo $fname
}



file_ext() {
    fullfilename=$1
    filename=$(basename "$fullfilename")
    ext="${filename##*.}"
    if [ $ext == $(file_base $filename) ]; then
      ext=""
    fi
    echo $ext
}



list_sd_devices() {
    lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/sd?
    #echo - $(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/sd?)
    #lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/sd? 2> /dev/null 
    if ! [ $? = 0 ] ; then
        echo_red ERROR... No SD-cards found...
    fi
 
}



list_image_files(){
    ls -1 -s -h -w1 *.img *.zip *.xz  2> /dev/null
    if ! [ $? = 0 ] ; then
        echo_red ERROR... No Image-files found...
    fi
}


elapsed_time() {
    # paramaters are in seconds
    BEG=$1
    END=$2
    #echo_white  Step 3 took $(($(($(date +%s)-TIME3))/60)) min
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
    #echo $(( $(( $END-$BEG ))/60/60)) : $(( $(( $END-$BEG ))/60)) : $(( $(( $END-$BEG ))%60 )) 
}



get_tools() {
    echo -n Checking to see if required tools are installed ...
    if [ ! -f /usr/local/bin/pishrink.sh ] || [ ! -f /usr/bin/zip ] || [ ! -f /usr/bin/xz ] ; then
    
        #echo We need several software packages.  PiShrink, zip and xz.
        echo
        read  -p "Install needed tools:  PiShrink, zip and xz-tools [y,N]?" -n 1 -r RESULT
        echo
        if [ $RESULT == "y" ]; then
        
            # Install PiShrink if needed
            if [ ! -f /usr/local/bin/pishrink.sh ]; then
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                echo pishrink installed.
            fi

            # get zip if needed
            if [ ! -f /usr/bin/zip ]; then
                echo_white Installing zip...
                sudo apt install zip -y
            fi
            
            # get xz if needed
            if [ ! -f /usr/bin/xz ]; then
                echo_white Installing xz-utils...
                sudo apt install xz-utils -y
            fi
            
            # get gzip if needed
            if [ ! -f /usr/bin/pigz ]; then
                echo_white Installing pigz...
                sudo apt install pigz -y
            fi
            
        else
            echo_red   WARNING.  Not all the needed tools are installed.
        fi
    else
        echo [OK]
    fi
}    



read_sd(){
    #get parameters
    INDEV=$1
    OUTFILE=$2
    OUTFILE_BASE=$(file_base $OUTFILE)
    OUTFILE_EXT=$(file_ext $OUTFILE)
    COMPRESSION=$3
    
    
    if [ -z $COMPRESSION ] ; then
        COMPRESSION=-1
    fi
    
    
    case $COMPRESSION in
    
        -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 )
            #echo Compression=$COMPRESSION of 9
        ;;
        
        
        *)
            COMPRESSION="1"
            #echo Compression=$COMPRESSION of 9
        ;;
        
    esac
    
    
    echo
    echo_white Read SD card


    # read the name of an sd device until it's size is greater than 0
    while [ $(sd_size_bytes $INDEV) -le 0 ]; do
        echo_red /dev/$INDEV not found.  Available SD devices are:
        #echo - $(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/sd? )
        #if ! [ $? = 0 ] ; then
        #  echo_red ERROR... No SD cards found...
        #fi
        echo $(list_sd_devices)
        echo "Enter SD device name (eg: sda)"
        read INDEV
    done
    
    echo_white SD card = \'$(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$INDEV)\'


    # warning if sd is larger than 16GB
    echo -n Checking for SD card over 16GB ...
    if (( $(sd_size_bytes $INDEV) > 16000000000 )); then
        echo
        echo_red WARNING... $INDEV is $(sd_size $INDEV).   SD card is larger than 16GB, use a smaller SD card if you can. 
    fi    
    
    
    echo -n Checking to see if there is enough space on the drive ...
    SPACE_NEEDED=$(( $(sd_size_bytes $INDEV) + (( $(sd_size_bytes $INDEV) / 2)) ))
    #echo sd size = $(sd_size_bytes $INDEV)
    #echo 1.5=$SPACE_NEEDED
    
    if (( $SPACE_NEEDED > $(freespace_bytes) )); then
        echo
        echo_red ERROR... not enough free space on drive to create an image file.
        echo "SD size                      = $(sd_size $INDEV)"
        echo "Free space in current folder = $(freespace)"
        return
    else
        echo \'$(freespace)\' [OK]
    fi
    
    
    # add .zip if no file extension
    if [ ! -z "$OUTFILE" ] && [ -z "$OUTFILE_EXT" ]; then
        echo Adding .zip extension...
        OUTFILE=$OUTFILE.zip
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    fi


    # get OUTFILE
    while [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] || [ -f "$OUTFILE_BASE.img" ]; do
        if [ -f "$OUTFILE" ] ; then
            echo_red ERROR file $OUTFILE exists
        fi
        
        if [ -f "$OUTFILE_BASE.img" ] ; then
            echo_red ERROR file $OUTFILE_BASE.img exists
        fi
        
        echo "Enter name of new image file to create (eg: 2020-04-29-buster)"
        read OUTFILE
    done


    # add .zip if no file extension
    if [ ! -z "$OUTFILE" ] && [ -z "$OUTFILE_EXT" ]; then
        echo Adding .zip extension...
        OUTFILE=$OUTFILE.zip
        OUTFILE_BASE=$(file_base $OUTFILE)
        OUTFILE_EXT=$(file_ext $OUTFILE)
    fi

    echo_white Image file = \'$OUTFILE\'

    #echo Compression=$COMPRESSION of 9

    echo -n Checking for supported file extension ...
    case $OUTFILE_EXT in
        img | zip | xz | gz)
            echo \'$OUTFILE_EXT\' [OK]
        ;;
        
        
        *)
            echo
            echo_red ERROR: Unsupported file extension \'$OUTFILE_EXT\'.
            exit 1
        ;;
    
    esac


  
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img

    echo
    read -p "Create image-file "\'$OUTFILE\'" from "\'/dev/$INDEV\'" [y,N] ?"  -n 1 -r RESULT
    echo

    if [ $RESULT == "y" ]; then
        TIME1=$(date +%s)
        echo
        echo_white Step 1 - Reading SD card to $OUTFILE_BASE.img ...
        date
        echo $(sd_size $INDEV ) to read
        sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE_BASE.img status=progress conv=fsync 
        sleep 5s
        echo Done reading SD card
        echo_white $(ls -s -h $OUTFILE_BASE.img)
        TIME2=$(date +%s)  
        echo_white Step 1 took $(elapsed_time $TIME1 $TIME2)
        echo
       
        echo_white Step 2 - Shrinking filesystem with PiShrink ...
        sudo pishrink.sh $OUTFILE_BASE.img
        echo Done shrinking filesystem
        echo_white $(ls -s -h $OUTFILE_BASE.img)
        TIME3=$(date +%s)
        echo_white Step 2 took $(elapsed_time $TIME2 $TIME3)

       
        echo
        echo_white Step 3 - Compressing $OUTFILE_BASE.img to $OUTFILE ...
        
        echo Compression level set to $COMPRESSION out of -9
       
        case $(file_ext $OUTFILE) in
            img)
                echo not compressing .img file ...
            ;;
            
            zip)
                 zip -db -dd -m $COMPRESSION $OUTFILE_BASE.zip $OUTFILE_BASE.img
            ;;
            
            xz)
                xz -z -v -T0 $COMPRESSION $OUTFILE_BASE.img
                mv $OUTFILE_BASE.img.xz $OUTFILE_BASE.xz
            ;;
            
            gz)
                pigz -v $COMPRESSION $OUTFILE_BASE.img
                mv $OUTFILE_BASE.img.gz $OUTFILE_BASE.gz
            ;;
            
            
            *)
                echo_red ERROR... unsupported file extension \'$(file_ext $OUTFILE)\'.
            ;;
        esac
       
        echo Done compressing $OUTFILE_BASE.img to $OUTFILE
        echo_white $(ls -s -h $OUTFILE)
        TIME4=$(date +%s)
        echo_white  Step 3 took $(elapsed_time $TIME3 $TIME4)

        echo
        echo_white $(sd_size $INDEV) SD card compressed to $(image_size $OUTFILE) in $(elapsed_time $TIME1 $TIME4)
        echo_white You can rename $OUTFILE, but it is highly recomended to leave the extension as \'.$(file_ext $OUTFILE)\'.
        echo_white  You can remove the SD card in /dev/$INDEV now.
    fi  
}  



write_sd() {
    #get parameters
    INFILE=$1
    OUTDEV=$2
    echo_white Write SD card
    
    
    # get INFILE
    echo_white Getting Image-file ...
    while [ ! -f "$INFILE" ] ; do
        echo_red \'$INFILE\' does not exist
        echo_white Available image files:
        list_image_files
        echo "Enter image-file: (eg: 2020-04-29-buster.img)"
        read INFILE
    done
    
    echo_white Image-file = \'$INFILE\'
    echo
    
    # get OUTDEV
    echo_white Getting SD-card ...
    while [ -z "$OUTDEV" ] || [ ! -e "/dev/$OUTDEV" ] ; do
        echo_red /dev/$OUTDEV not found.
        echo_white Available devices are:
        echo
        #echo - $(lsblk -d -n -l -o NAME,VENDOR,MODEL,TYPE,SIZE /dev/sd? )
        list_sd_devices
        echo
        echo "Enter SD device name (eg: sda)"
        read OUTDEV
    done


    # Check if imagefile will fit on device
    if (( $(image_size_bytes $INFILE) > $(sd_size_bytes $OUTDEV) )); then
        echo_red ERROR... Image file is larger than sd card.
        echo "Image size =$(image_size $INFILE)"
        echo "Device size=$(sd_size $OUTDEV)"
        #return
    fi
    
    
    # Check if device is large... maybe the wrong device
        if (( $(sd_size_bytes $OUTDEV) > 16000000000 )); then
        echo_red WARNING... SD card \'$(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$OUTDEV)\' is bigger than 16GB... Is this the right device?
        #echo "$OUTDEV size=$(sd_size $OUTDEV)"
        read -p "You must type 'OK' to continue:"  -r RESULT
        if ! [ $RESULT == "OK" ]; then
            echo Exiting...
            exit
        fi
        echo
    fi

    SD_CARD=$(lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE /dev/$OUTDEV)
    echo This will write \'$INFILE\' to \'$SD_CARD\'
    echo_red WARNING... All existing data on \'/dev/$OUTDEV\' - will be erased!
    read  -p "You must type 'YES' to continue:" -r RESULT
    echo
    if [ $RESULT == "YES" ]; then
        
        echo Unmounting sd device ...
        umount /dev/$OUTDEV?
        
        date
        TIME1=$(date +%s)
    
        INFILEEXT=$(file_ext $INFILE)
                
        echo_white Writing $(image_size $INFILE) to sd card ...     
        
        case $INFILEEXT in
            img)
                sudo dd if=$INFILE of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;
            
            
            zip)
                unzip -p $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            xz)
                xz -v -d -c $INFILE | sudo dd of=/dev/$OUTDEV bs=4M conv=fsync status=progress
            ;;


            *)
                echo_red ERROR.  Unsupported file extension.  
            ;;

        esac        
   
        echo_white Total time $(elapsed_time $TIME1 $(date +%s))
        echo_white  You can remove the SD card in /dev/$OUTDEV now
    else
        echo Exiting... did not answer \'YES\'
    fi
}



list_info() {
    echo
    echo_white  Current directory:
    echo Freespace in current directory is $(freespace)
    echo

    echo_white SD card devices:
    #echo $(list_sd_devices)
    list_sd_devices
    echo
    
    echo_white Image files:
    #ls -s -h -w1 *.img *.zip *.xz  2> /dev/null
    list_image_files
}    



install_sd() {    
    if [ -f /usr/local/bin/sd ]; then
        echo_red WARNING... sd already in /usr/local/bin. 
        echo Installed ver=$(/usr/local/bin/sd -v)
    fi
    
    read -p "Install sd v$SD_VER to /usr/local/bin/sd [y,N] ? " -n 1 -r RESULT
    echo
    
    if [ $RESULT == "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/sd
        sudo chmod +x /usr/local/bin/sd
        echo Installed ver=$(/usr/local/bin/sd -v)
    else
        echo Not installed.
    fi
}



#echo "All OPTS: ${@}"

#verbose=false
#auto_yes=false

#while getopts ":yv" opt; do
#  case "${opt}" in
#    y) auto_yes=true;;
#    v) verbose=true;;
#    *) help;;
#  esac
#done
#shift $((OPTIND-1))


#echo $verbose
#echo $auto_yes




# intro
if [ -z "$1" ] || ! [ $1 == "-v" ]; then
    echo "Copyright (c) 2018-2020 Richard Reed"
    echo sd imager v$SD_VER

    get_tools
fi



case $1 in
    
    list)
        list_info
    ;;
    
    
    read)
          read_sd $2 $3 $4
    ;;
    
    
    write)
          write_sd $2 $3
    ;;
    
    
    install)
        install_sd
    ;;
    
    
    -v)
        echo $SD_VER
    ;;
    
    
    *)
        help
    ;;

esac



